"// # FILE: .\Run.jl";

using Pkg
using Dates
using CUDA


const C_RESET = "\u001b[0m"
const C_BOLD = "\u001b[1m"
const C_RED = "\u001b[31m"
const C_GREEN = "\u001b[32m"
const C_YELLOW = "\u001b[33m"
const C_BLUE = "\u001b[34m"
const C_MAGENTA = "\u001b[35m"
const C_CYAN = "\u001b[36m"
const C_WHITE = "\u001b[37m"

function print_banner()
    println("="^60)
    println(">>> [LAUNCHER] HEXA TopOpt: Robust Environment Setup")
    println(">>> [INFO] Time: $(Dates.now()) | Julia Version: $(VERSION)")
    println("="^60)
end

function activate_environment()
    project_dir = @__DIR__
    println(">>> [ENV] Activating project at: $project_dir")
    Pkg.activate(project_dir)
    flush(stdout)
end

function instantiate_environment()
    println(">>> [ENV] Attempting to instantiate environment...")
    flush(stdout)
    
    try
        Pkg.instantiate()
        println("[OK]")
    catch e
        println(C_RED * "[FAILED]" * C_RESET)
        println(">>> [ERROR] Failed to instantiate environment:")
        showerror(stdout, e, catch_backtrace())
        println("\n>>> [HINT] Try running: julia --project=. -e 'using Pkg; Pkg.resolve(); Pkg.instantiate()'")
        exit(1)
    end
    flush(stdout)
end

function verify_packages()
    println(">>> [ENV] Verifying core package list...")
    flush(stdout)
    
    required_packages = [
        "LinearAlgebra",
        "SparseArrays", 
        "Printf",
        "JSON",
        "Statistics",
        "CUDA",
        "YAML"
    ]
    
    installed_packages = [p.name for p in values(Pkg.dependencies())]
    
    missing_packages = String[]
    for pkg in required_packages
        if !(pkg in installed_packages)
            push!(missing_packages, pkg)
        end
    end
    
    if !isempty(missing_packages)
        println(C_RED * "[MISSING PACKAGES]" * C_RESET)
        println(">>> [ERROR] The following required packages are missing:")
        for pkg in missing_packages
            println("    - $pkg")
        end
        println("\n>>> [HINT] Run: julia --project=. -e 'using Pkg; Pkg.add([\"$(join(missing_packages, "\", \""))\"])'")
        exit(1)
    end
    
    println("[OK]")
    flush(stdout)
end

function precompile_environment()
    println(">>> [ENV] Precompiling project...")
    flush(stdout)
    
    try
        Pkg.precompile()
    catch e
        println(C_YELLOW * "!!! [WARN] Precompilation had warnings (safe to ignore if code runs)." * C_RESET)
    end
    flush(stdout)
end

function check_cuda_availability()
    println(">>> [GPU] Checking CUDA availability...")
    flush(stdout)
    
    if CUDA.functional()
        dev = CUDA.device()
        name = CUDA.name(dev)
        mem_gb = CUDA.total_memory() / 1024^3
        println(C_GREEN * ">>> [GPU] CUDA Available: $name ($(round(mem_gb, digits=2)) GB)" * C_RESET)
    else
        println(C_YELLOW * ">>> [GPU] No CUDA GPU detected. Will run in CPU mode (slow)." * C_RESET)
    end
    flush(stdout)
end

function generate_machine_limits()
    config_dir = joinpath(@__DIR__, "configs")
    if !isdir(config_dir); mkpath(config_dir); end
    limit_file = joinpath(config_dir, "_machine_limits.jl")

    
    current_gpu_id = "CPU_ONLY"
    current_vram = 0
    
    if CUDA.functional()
        dev = CUDA.device()
        gpu_name = CUDA.name(dev)
        total_vram = CUDA.total_memory()
        current_gpu_id = "$gpu_name-$(div(total_vram, 1024^3))GB"
        current_vram = total_vram
    end

    
    if isfile(limit_file)
        println(">>> [HARDWARE] Limits file found: $limit_file")
        
        
        file_content = read(limit_file, String)
        
        # Look for GPU ID in file (we'll add it as a comment)
        if occursin("# GPU_ID: $current_gpu_id", file_content)
            println(">>> [HARDWARE] GPU Match: $current_gpu_id")
            println(">>> [HARDWARE] Skipping stress test. Delete file to re-run.")
            return
        else
            println(C_YELLOW * ">>> [HARDWARE] GPU CHANGED - Previous limits invalid!" * C_RESET)
            println(">>> [HARDWARE] Previous GPU in file, current GPU: $current_gpu_id")
            println(">>> [HARDWARE] Deleting old limits and re-testing...")
            rm(limit_file, force=true)
        end
    end

    if !CUDA.functional()
        println(C_YELLOW * ">>> [HARDWARE] No GPU detected. Skipping VRAM stress test." * C_RESET)
        return
    end

    println("\n" * C_MAGENTA * "="^60 * C_RESET)
    println(C_MAGENTA * C_BOLD * ">>> [HARDWARE] RUNNING VRAM STRESS TEST (GMG SOLVER)" * C_RESET)
    println(C_MAGENTA * ">>> determining maximum safe element count for this machine..." * C_RESET)
    println(C_MAGENTA * "="^60 * C_RESET)

    
    function attempt_allocation(nElem_target)
        
        GC.gc()
        CUDA.reclaim()
        
        
        n = round(Int, cbrt(nElem_target))
        nx, ny, nz = n, n, n
        
        nNodes_f = (nx+1)*(ny+1)*(nz+1)
        nElem_f = nx*ny*nz
        
        try
            
            
            v1 = CUDA.zeros(Float32, nNodes_f * 3)  
            v2 = CUDA.zeros(Float32, nNodes_f * 3)  
            v3 = CUDA.zeros(Float32, nNodes_f * 3)  
            v4 = CUDA.zeros(Float32, nNodes_f * 3)  
            v5 = CUDA.zeros(Float32, nNodes_f * 3)  
            v6 = CUDA.zeros(Float32, nNodes_f * 3)  
            
            
            conn = CUDA.zeros(Int32, nElem_f * 8)      
            factors = CUDA.zeros(Float32, nElem_f)      
            
            
            buffers = []
            current_nx, current_ny, current_nz = nx, ny, nz
            
            for level in 2:4
                
                current_nx = max(1, div(current_nx, 2))
                current_ny = max(1, div(current_ny, 2))
                current_nz = max(1, div(current_nz, 2))
                
                nNodes_c = (current_nx+1)*(current_ny+1)*(current_nz+1)
                nElem_c  = current_nx*current_ny*current_nz
                
                
                push!(buffers, CUDA.zeros(Float32, nNodes_c * 3))  
                push!(buffers, CUDA.zeros(Float32, nNodes_c * 3))  
                push!(buffers, CUDA.zeros(Float32, nNodes_c * 3))  
                push!(buffers, CUDA.zeros(Float32, nElem_c))        
                push!(buffers, CUDA.zeros(Int32, nElem_c * 8))      
            end
            
            
            CUDA.synchronize()
            
            return true
        catch e
            
            return false
        end
    end

    
    safe_limit = 500_000  
    
    
    
    
    
    
    
    
    start_elems = 2_000_000     
    step_elems  = 3_000_000     
    
    
    
    
    
    
    
    
    total_mem = CUDA.total_memory()
    est_max = total_mem / 300  
    
    
    end_elems = min(200_000_000, floor(Int, est_max * 1.3))  

    println(">>> [TEST] GPU Memory: $(round(total_mem / 1024^3, digits=2)) GB")
    println(">>> [TEST] Estimated max GMG elements: $(round(Int, est_max / 1_000_000))M ($(round(Int, est_max)) elements)")
    println(">>> [TEST] Search range: $(round(Int, start_elems / 1_000_000))M to $(round(Int, end_elems / 1_000_000))M elements")
    println(">>> [TEST] Step size: $(round(Int, step_elems / 1_000_000))M elements")
    println(">>> [TEST] Estimated test duration: 1-3 minutes")
    flush(stdout)

    test_count = 0
    last_pass_time = 0.0
    for count in start_elems:step_elems:end_elems
        test_count += 1
        test_start = time()
        
        count_millions = round(count / 1_000_000, digits=1)
        print("    [$(lpad(test_count, 2))] Testing $(lpad(count_millions, 5))M elements... ")
        flush(stdout)
        
        if attempt_allocation(count)
            test_duration = time() - test_start
            last_pass_time = test_duration
            println(C_GREEN * "[PASS]" * C_RESET * " ($(round(test_duration, digits=1))s)")
            safe_limit = count
            
            GC.gc()
            CUDA.reclaim()
        else
            test_duration = time() - test_start
            println(C_RED * "[FAIL - OOM]" * C_RESET * " ($(round(test_duration, digits=1))s)")
            println(C_YELLOW * ">>> [TEST] Crash point found at $(round(count / 1_000_000, digits=1))M elements" * C_RESET)
            println(C_YELLOW * ">>> [TEST] Safe limit: $(round(safe_limit / 1_000_000, digits=1))M elements" * C_RESET)
            break
        end
        
        
        sleep(0.2)
    end

    
    if safe_limit == floor(Int, (end_elems - start_elems) / step_elems) * step_elems + start_elems
        println(C_CYAN * ">>> [TEST] Reached search limit without OOM. GPU may support even larger meshes." * C_RESET)
    end

    
    
    
    
    final_limit = floor(Int, safe_limit * 0.80)  
    
    
    vram_used_estimate = safe_limit * 300  
    actual_bytes_per_elem = round(Int, vram_used_estimate / safe_limit)
    
    println("\n" * C_CYAN * "="^60 * C_RESET)
    println(C_GREEN * C_BOLD * ">>> [RESULT] Maximum Safe Elements: $(round(final_limit / 1_000_000, digits=1))M" * C_RESET)
    println(C_CYAN * "    Raw Crash Point:     $(round(safe_limit / 1_000_000, digits=1))M elements" * C_RESET)
    println(C_CYAN * "    Safety Margin:       20% reduction applied (Application Buffer)" * C_RESET)
    println(C_CYAN * "    Estimated VRAM:      ~$(round(actual_bytes_per_elem * final_limit / 1024^3, digits=2)) GB at limit" * C_RESET)
    println(C_CYAN * "="^60 * C_RESET)
    
    println(">>> [HARDWARE] Writing limits to $limit_file")
    open(limit_file, "w") do io
        write(io, "# MACHINE SPECIFIC LIMITS - GENERATED AUTOMATICALLY\n")
        write(io, "# GPU_ID: $current_gpu_id\n")
        write(io, "# Generated: $(Dates.now())\n")
        write(io, "# Total VRAM: $(round(current_vram/1024^3, digits=2)) GB\n")
        write(io, "# Tested Range: $(round(start_elems/1e6, digits=1))M to $(round(safe_limit/1e6, digits=1))M elements\n")
        write(io, "# Crash Point: $(round(safe_limit/1e6, digits=1))M elements\n")
        write(io, "# \n")
        write(io, "# These limits were determined by stress-testing GMG solver memory allocation.\n")
        write(io, "# The test simulates the full memory footprint of the geometric multigrid solver:\n")
        write(io, "#   - Finest level: 6 vectors (r, p, Ap, x, z, temp) + element data\n")
        write(io, "#   - Coarse levels: 3 vectors per level + element data (3-4 levels)\n")
        write(io, "# \n")
        write(io, "# SAFETY MARGIN: 20% (Increased from 5% to account for topology overhead)\n")
        write(io, "# Empirical data shows this prevents swap death at mesh refinement peak.\n")
        write(io, "# \n")
        write(io, "# MEMORY ESTIMATE: ~$(actual_bytes_per_elem) bytes per element (varies with mesh size)\n")
        write(io, "#   - Small meshes (5M): ~400 bytes/element\n")
        write(io, "#   - Large meshes (30M+): ~200 bytes/element\n")
        write(io, "#   - Fixed overhead amortized across elements\n")
        write(io, "# \n")
        write(io, "# To re-test (e.g., after GPU upgrade or driver update):\n")
        write(io, "#   Delete this file and restart the application.\n")
        write(io, "# \n")
        write(io, "module MachineLimits\n")
        write(io, "    # GMG (Geometric Multigrid) Solver Limit\n")
        write(io, "    # This is the maximum element count for the memory-intensive GMG preconditioner\n")
        write(io, "    const MAX_GMG_ELEMENTS = $final_limit\n")
        write(io, "    \n")
        write(io, "    # Jacobi Preconditioner Limit\n")
        write(io, "    # Jacobi uses significantly less memory than GMG (no coarse level hierarchy)\n")
        write(io, "    # Empirical data shows Jacobi can handle 3-4x more elements than GMG\n")
        write(io, "    # Conservative estimate: 2.5x GMG limit\n")
        write(io, "    const MAX_JACOBI_ELEMENTS = $(floor(Int, final_limit * 2.5))\n")
        write(io, "end\n")
    end
    
    println(C_GREEN * C_BOLD * ">>> [HARDWARE] Setup Complete!" * C_RESET)
    println(">>> [HARDWARE] Max GMG Elements:    $(round(final_limit / 1_000_000, digits=1))M elements")
    println(">>> [HARDWARE] Max Jacobi Elements: $(round(final_limit * 2.5 / 1_000_000, digits=1))M elements")
    println(C_CYAN * "-"^60 * C_RESET)
    flush(stdout)
end

function launch_main()
    println("-"^60)
    println(">>> [LAUNCHER] Handing off to Main.jl...")
    flush(stdout)
    
    main_script = joinpath(@__DIR__, "src", "Main.jl")
    
    if !isfile(main_script)
        println(C_RED * ">>> [ERROR] Main.jl not found at: $main_script" * C_RESET)
        exit(1)
    end
    
    
    include(main_script)
end

function main()
    try
        print_banner()
        activate_environment()
        instantiate_environment()
        verify_packages()
        precompile_environment()
        println(">>> [ENV] Environment Ready.")
        flush(stdout)
        
        check_cuda_availability()
        generate_machine_limits()
        
        launch_main()
        
    catch e
        if isa(e, InterruptException)
            println("\n" * C_YELLOW * ">>> [LAUNCHER] Interrupted by user." * C_RESET)
            exit(0)
        else
            println("\n" * C_RED * ">>> [LAUNCHER] Fatal error during setup:" * C_RESET)
            showerror(stderr, e, catch_backtrace())
            println("\n")
            exit(1)
        end
    end
end


main()
"// # FILE: .\configs\_machine_limits.jl";























module MachineLimits
    
    
    const MAX_GMG_ELEMENTS = 35200000
    
    
    
    
    
    const MAX_JACOBI_ELEMENTS = 88000000
end
"// # FILE: .\configs\bridge_v1.yaml";
# FILE: .\configs\domain_definitions.yaml
# ==============================================================================
# PART 1: PHYSICAL PROBLEM DEFINITION
# ==============================================================================
# This file contains the "What": Geometry, Loads, BCs, and Materials.


# ------------------------------------------------------------------------------
# GEOMETRY DEFINITION
# ------------------------------------------------------------------------------
geometry:
  length_x: 80
  length_y: 20
  length_z: 10
  sphere1:
    type: sphere
    center: [12.51, 28.49, 50]
    diameter: 8
    properties:
      stiffness_ratio: 0
      specific_mass: 0
      thermal_expansion: 0
  sphere2:
    type: sphere
    center: [60.38, -0.07, 50]
    diameter: 4
    properties:
      stiffness_ratio: 10
      specific_mass: 0
      thermal_expansion: 0.000012
  sphere3:
    type: sphere
    center: [34.29, 5, 50]
    diameter: 4
    properties:
      stiffness_ratio: 1
      specific_mass: 0
      thermal_expansion: 0.0002
  box1:
    type: box
    center: [40, 11.83, 5.01]
    size: [90, 5, 8.9]
    properties:
      stiffness_ratio: 0
      specific_mass: 0
      thermal_expansion: 0
  box2:
    type: box
    center: [40, 9, 5]
    size: [90, 0.6, 12]
    properties:
      stiffness_ratio: .01
      specific_mass: 0.015
      thermal_expansion: 0

# ------------------------------------------------------------------------------
# BOUNDARY CONDITIONS
# ------------------------------------------------------------------------------
boundary_conditions:
  - location: [0%, 30%, ':']
    DoFs: [1, 2, 3]
  - location: [100%, 30%, ':']
    DoFs: [2, 3]

# ------------------------------------------------------------------------------
# EXTERNAL FORCES
# ------------------------------------------------------------------------------
external_forces:
  - name: Y10
    location: [80, 0, 0]
    F: [0, 0.00001, 0]
  - name: Z-10
    location: [40, 9, 5]
    F: [0, 0, -0.0010]
  - name: Y20
    location: [80, 0, 10]
    F: [0, 0.00002, 0]
  - name: Mid_Y20
    location: [40, 0, 5]
    F: [0, 0.000015, 0]

# ------------------------------------------------------------------------------
# MATERIAL PROPERTIES
# ------------------------------------------------------------------------------
material:
  E: 1
  nu: 0.3
  material_density: 0.00
  gravity_acceleration: 10
  delta_temperature: 0
  l1_stress_allowable_tension: 2
  l1_stress_allowable_compression: 1.5
 
"// # FILE: .\configs\domain_definitions.yaml";
# FILE: .\configs\domain_definitions.yaml
# ==============================================================================
# PART 1: PHYSICAL PROBLEM DEFINITION
# ==============================================================================
# This file contains the "What": Geometry, Loads, BCs, and Materials.

# ------------------------------------------------------------------------------
# GEOMETRY DEFINITION
# ------------------------------------------------------------------------------
geometry:
  # Physical dimensions (meters)
  length_x: 60
  length_y: 20
  length_z: 20
  
  # Geometric primitives (Design/Non-Design regions)
  # NEW SCHEMA:
  # properties:
  #   stiffness_ratio:   Multiplier for Young's Modulus (0 = Void)
  #   specific_mass:     Override for density (kg/m3). If stiffness=0, this is forced to 0.
  #   thermal_expansion: Override for alpha coefficient.

  sphere1:
    type: sphere
    center: [12.51, 28.49, 50]
    diameter: 8
    properties:
      stiffness_ratio: 0        # Void
      specific_mass: 0          # No mass
      thermal_expansion: 0
    
  sphere2:
    type: sphere
    center: [60.38, -0.07, 50]
    diameter: 4
    properties:
      stiffness_ratio: 10       # Stiff inclusion (10x E)
      specific_mass: 7850       # Heavy inclusion (Steel density)
      thermal_expansion: 1.2e-5 # Standard thermal expansion
    
  sphere3:
    type: sphere
    center: [34.29, 5, 50]
    diameter: 4
    properties:
      stiffness_ratio: 1        # Normal Stiffness
      specific_mass: 100        # Light material
      thermal_expansion: 2.0e-4 # High thermal expansion (Active Thermal)
      
  box1:
    type: box
    center: [28, 15, 50]
    size: [1, 2, 3]
    stiffness_ratio: 5          # Legacy syntax supported (implies mass=global, alpha=0)
      
  box2:
    type: box
    center: [45.06, 8.95, 50]
    size: [1, 4, 2]
    stiffness_ratio: 0          # Void box

  box3:
    type: box
    center: [40, 9, 5]
    size: [90, 0.6, 12]
    properties:
      stiffness_ratio: 1
      specific_mass: 0.021
      thermal_expansion: 0

# ------------------------------------------------------------------------------
# BOUNDARY CONDITIONS
# ------------------------------------------------------------------------------
boundary_conditions:
  - location: [0, 0, ':'] # Fix X=0 face
    DoFs: [1, 2, 3]         # Fully fixed

# ------------------------------------------------------------------------------
# EXTERNAL FORCES
# ------------------------------------------------------------------------------
external_forces:
  - name: Y10
    location: [100%, 0, 0]
    F: [0, 10, 0]
    
  - name: Z-10
    location: [100%, 0, 50%]
    F: [0, 0, -10]
    
  - name: Y20
    location: [100%, 0, 100%]
    F: [0, 20, 0]
    
  - name: Mid_Y20
    location: [50%, 0, 50%]
    F: [0, 15, 0]

# ------------------------------------------------------------------------------
# MATERIAL PROPERTIES
# ------------------------------------------------------------------------------
material:
  E: 1                      # Young's Modulus (Base)
  nu: 0.3                   # Poisson's Ratio
  material_density: 0.001   # Global Base specific mass (kg/m3) for self-weight
  gravity_acceleration: 10.0
  delta_temperature: 0.0
 

 # Asymmetric Stress Limits (Positive Values)
  l1_stress_allowable_tension: 1.
  l1_stress_allowable_compression: 1.
"// # FILE: .\configs\optimization_cases.yaml";
# FILE: .\configs\optimization_cases.yaml
# ==============================================================================
# OPTIMIZATION CASES ORCHESTRATOR
# ==============================================================================
# This file defines a sequence of simulations to run. 
# It merges a physics definition with a solver definition for each run.

batch_queue:
  # ----------------------------------------------------------------------------
  # Run 1: Standard RTX configuration
  # ----------------------------------------------------------------------------
  
  - job_name: "Bridge_2"
    domain_config: "./configs/bridge_v1.yaml"
    solver_config: "./configs/solver_settings_2.yaml"
  
  - job_name: "Bridge_3"
    domain_config: "./configs/bridge_v1.yaml"
    solver_config: "./configs/solver_settings_3.yaml"

  - job_name: "Bridge_4"
    domain_config: "./configs/bridge_v1.yaml"
    solver_config: "./configs/solver_settings_4.yaml"

"// # FILE: .\configs\solver_settings.yaml";
# FILE: .\configs\solver_settings.yaml
# ==============================================================================
# PART 2: NUMERICAL SOLVER & OPTIMIZATION SETTINGS
# ==============================================================================
# This file contains the "How": Solver precision, filtering, optimization loop.

# ------------------------------------------------------------------------------
# HARDWARE PROFILE
# ------------------------------------------------------------------------------
gpu_profile: "RTX" # Options: RTX, V100, A100, H100, AUTO

# ------------------------------------------------------------------------------
# RESTART CONFIGURATION
# ------------------------------------------------------------------------------
restart_configuration:
  enable_restart: false
  file_path: ""

# ------------------------------------------------------------------------------
# MESH & ADAPTIVITY SETTINGS
# ------------------------------------------------------------------------------
mesh_settings:
  # Initial background grid resolution (RENAMED)
  initial_ground_mesh_size: 3_000_000

  # Adaptive Mesh Refinement (AMR) targets (RENAMED)
  final_target_of_active_elements: 60_000_000
  
  max_growth_rate: 1.1
  nominal_refinement_threshold: 0.9
  exponent_for_refinement_schedule: 2.0
  max_background_elements: 500_000_000
  gpu_solver_safety_factor: 0.95

# ------------------------------------------------------------------------------
# OPTIMIZATION LOOP
# ------------------------------------------------------------------------------
number_of_iterations: 40
hard_stop_after_iteration: 250

optimization_parameters:
  density_update_method: "hard"
  min_density: 0.0001
  density_clamp_max: 1
  
  # Culling schedule
  final_density_threshold: 0.90
  exponent_for_cutoff_schedule: 1.5 
  max_culling_ratio: 0.2

  # Filter Radius Parameters
  minimum_feature_size_physical: 0.1
  minimum_feature_size_elements: 1.0
  radius_max_multiplier: 1.0
  radius_min_multiplier: 1
  radius_decay_exponent: 1.8
  constraint_constant: 0.25

# ------------------------------------------------------------------------------
# SOLVER PARAMETERS
# ------------------------------------------------------------------------------
solver_parameters:
  solver_type: gpu              
  preconditioner: "multigrid"
  tolerance: 1.e-6 
  max_iterations: 30000 
  diagonal_shift_factor: 1.e-7 
  stagnation_tolerance: 1.0e-3
  max_shift_attempts: 7
  shift_multiplier: 10.0
  gpu_method: krylov        
  krylov_solver: cg              

# ------------------------------------------------------------------------------
# OUTPUT SETTINGS
# ------------------------------------------------------------------------------
output_settings:
  export_frequency: 1       
  save_bin_frequency: 1     
  save_STL_frequency: 10     
  save_VTK_frequency: 1     
  save_principal_stress_vectors: no
  log_filename: simulation_log.txt
  iso_surface_threshold: 0.01
  stl_subdivision_level: 2       
  stl_smoothing_passes: 2        
  stl_mesh_smoothing_iters: 6    
  maximum_cells_in_binary_output: 25_000_000
  stl_target_triangle_count: 95000
"// # FILE: .\configs\solver_settings_1.yaml";
# FILE: .\configs\solver_settings.yaml
# ==============================================================================
# PART 2: NUMERICAL SOLVER & OPTIMIZATION SETTINGS
# ==============================================================================

# ------------------------------------------------------------------------------
# HARDWARE PROFILE
# ------------------------------------------------------------------------------
gpu_profile: "RTX" 

# ------------------------------------------------------------------------------
# RESTART CONFIGURATION
# ------------------------------------------------------------------------------
restart_configuration:
  enable_restart: false
  file_path: ""

# ------------------------------------------------------------------------------
# MESH & ADAPTIVITY SETTINGS
# ------------------------------------------------------------------------------
mesh_settings:
  initial_ground_mesh_size: 15_500_000
  final_target_of_active_elements: 15_500_000
  
  max_growth_rate: 1.1
  nominal_refinement_threshold: 0.9
  # exponent_for_refinement_schedule REMOVED (Unused)
  max_background_elements: 800_000_000
  gpu_solver_safety_factor: 0.95

# ------------------------------------------------------------------------------
# OPTIMIZATION LOOP
# ------------------------------------------------------------------------------
number_of_iterations: auto
hard_stop_after_iteration: 200

optimization_parameters:
  density_update_method: "hard"

  min_density: 0.0001
  density_clamp_max: 1
  
  # AGGRESSIVE CULLING CONFIGURATION
  # ---------------------------------------------------------
  max_culling_ratio: 0.20    # Allow up to 20% of elements to die per step
  starting_density_threshold: 0.02 # Starting cutoff value
  final_density_threshold: 0.90
  exponent_for_cutoff_schedule: 1.0 # Controls how fast the cutoff rises (Lower = Faster rise)
  # ---------------------------------------------------------

  # FILTER RADIUS (Decay Faster)
  minimum_feature_size_physical: 0.1
  minimum_feature_size_elements: 1.5 

  radius_max_multiplier: 1.0 
  radius_min_multiplier: 1.0  
  radius_decay_exponent: 0.8  # Drop radius quickly to allow fine details
  
 

# ------------------------------------------------------------------------------
# STRESS CONTROLLER SETTINGS
# ------------------------------------------------------------------------------
# PID and logic parameters for the adaptive stress constraint controller
stress_controller:
  Kp: 0.02
  Ki: 0.005
  integral_error_limit: 50.0        # Clamp for integral windup (-50, +50)
  max_adjustment_pct: 0.05          # Max adjustment per iter (+/- 5%)
  state_switch_error_low: 0.05      # 5% error threshold to trigger Relaxing
  state_switch_error_high: 0.15     # 15% error threshold (if variance is high)
  min_variance_for_switch: 0.25     # Min stress variance to allow high-error switch
  metric_percentile: 0.95           # Percentile for stress metric (95th)

# ------------------------------------------------------------------------------
# SOLVER PARAMETERS
# ------------------------------------------------------------------------------
solver_parameters:
  solver_type: gpu              
  preconditioner: "multigrid"
  tolerance: 1.e-6 
  max_iterations: 30000 
  diagonal_shift_factor: 1.e-7 
  stagnation_tolerance: 1.0e-3
  max_shift_attempts: 7
  shift_multiplier: 10.0
  gpu_method: krylov        
  krylov_solver: cg               

# ------------------------------------------------------------------------------
# OUTPUT SETTINGS
# ------------------------------------------------------------------------------
output_settings:
  export_frequency: 1        
  save_bin_frequency: 1     
  save_STL_frequency: 1     
  save_VTK_frequency: 1     
  save_principal_stress_vectors: yes
  save_displacement_vectors: yes
  log_filename: 00_simulation_log.txt
  iso_surface_threshold: 0.01
  stl_subdivision_level: 0        
  stl_smoothing_passes: 1         
  stl_mesh_smoothing_iters: 3     
  maximum_cells_in_binary_output: 25_000_000
  stl_target_triangle_count: 500000
"// # FILE: .\configs\solver_settings_2.yaml";
# FILE: .\configs\solver_settings.yaml
# ==============================================================================
# PART 2: NUMERICAL SOLVER & OPTIMIZATION SETTINGS
# ==============================================================================

# ------------------------------------------------------------------------------
# HARDWARE PROFILE
# ------------------------------------------------------------------------------
gpu_profile: "RTX" 

# ------------------------------------------------------------------------------
# RESTART CONFIGURATION
# ------------------------------------------------------------------------------
restart_configuration:
  enable_restart: false
  file_path: ""

# ------------------------------------------------------------------------------
# MESH & ADAPTIVITY SETTINGS
# ------------------------------------------------------------------------------
mesh_settings:
  initial_ground_mesh_size: 5_000_000
  final_target_of_active_elements: 5_000_000
  
  max_growth_rate: 1.1
  nominal_refinement_threshold: 0.9
  # exponent_for_refinement_schedule REMOVED (Unused)
  max_background_elements: 800_000_000
  gpu_solver_safety_factor: 0.95

# ------------------------------------------------------------------------------
# OPTIMIZATION LOOP
# ------------------------------------------------------------------------------
number_of_iterations: auto
hard_stop_after_iteration: 200

optimization_parameters:
  density_update_method: "hard"

  min_density: 0.0001
  density_clamp_max: 1
  
  # AGGRESSIVE CULLING CONFIGURATION
  # ---------------------------------------------------------
  max_culling_ratio: 0.20    # Allow up to 20% of elements to die per step
  starting_density_threshold: 0.02 # Starting cutoff value
  final_density_threshold: 0.90
  exponent_for_cutoff_schedule: 1.0 # Controls how fast the cutoff rises (Lower = Faster rise)
  # ---------------------------------------------------------

  # FILTER RADIUS (Decay Faster)
  minimum_feature_size_physical: 0.1
  minimum_feature_size_elements: 1.5 

  radius_max_multiplier: 1.0 
  radius_min_multiplier: 1.0  
  radius_decay_exponent: 0.8  # Drop radius quickly to allow fine details
  
 

# ------------------------------------------------------------------------------
# STRESS CONTROLLER SETTINGS
# ------------------------------------------------------------------------------
# PID and logic parameters for the adaptive stress constraint controller
stress_controller:
  Kp: 0.02
  Ki: 0.005
  integral_error_limit: 50.0        # Clamp for integral windup (-50, +50)
  max_adjustment_pct: 0.05          # Max adjustment per iter (+/- 5%)
  state_switch_error_low: 0.05      # 5% error threshold to trigger Relaxing
  state_switch_error_high: 0.15     # 15% error threshold (if variance is high)
  min_variance_for_switch: 0.25     # Min stress variance to allow high-error switch
  metric_percentile: 0.95           # Percentile for stress metric (95th)

# ------------------------------------------------------------------------------
# SOLVER PARAMETERS
# ------------------------------------------------------------------------------
solver_parameters:
  solver_type: gpu              
  preconditioner: "multigrid"
  tolerance: 1.e-6 
  max_iterations: 30000 
  diagonal_shift_factor: 1.e-7 
  stagnation_tolerance: 1.0e-3
  max_shift_attempts: 7
  shift_multiplier: 10.0
  gpu_method: krylov        
  krylov_solver: cg               

# ------------------------------------------------------------------------------
# OUTPUT SETTINGS
# ------------------------------------------------------------------------------
output_settings:
  export_frequency: 1        
  save_bin_frequency: 1     
  save_STL_frequency: 1     
  save_VTK_frequency: 1     
  save_principal_stress_vectors: yes
  save_displacement_vectors: yes
  log_filename: 00_simulation_log.txt
  iso_surface_threshold: 0.01
  stl_subdivision_level: 0        
  stl_smoothing_passes: 1         
  stl_mesh_smoothing_iters: 3     
  maximum_cells_in_binary_output: 25_000_000
  stl_target_triangle_count: 500000
"// # FILE: .\configs\solver_settings_3.yaml";
# FILE: .\configs\solver_settings.yaml
# ==============================================================================
# PART 2: NUMERICAL SOLVER & OPTIMIZATION SETTINGS
# ==============================================================================

# ------------------------------------------------------------------------------
# HARDWARE PROFILE
# ------------------------------------------------------------------------------
gpu_profile: "RTX" 

# ------------------------------------------------------------------------------
# RESTART CONFIGURATION
# ------------------------------------------------------------------------------
restart_configuration:
  enable_restart: false
  file_path: ""

# ------------------------------------------------------------------------------
# MESH & ADAPTIVITY SETTINGS
# ------------------------------------------------------------------------------
mesh_settings:
  initial_ground_mesh_size: 15_000_000
  final_target_of_active_elements: 15_000_000
  
  max_growth_rate: 1.1
  nominal_refinement_threshold: 0.9
  # exponent_for_refinement_schedule REMOVED (Unused)
  max_background_elements: 800_000_000
  gpu_solver_safety_factor: 0.95

# ------------------------------------------------------------------------------
# OPTIMIZATION LOOP
# ------------------------------------------------------------------------------
number_of_iterations: auto
hard_stop_after_iteration: 200

optimization_parameters:
  density_update_method: "hard"

  min_density: 0.0001
  density_clamp_max: 1
  
  # AGGRESSIVE CULLING CONFIGURATION
  # ---------------------------------------------------------
  max_culling_ratio: 0.20    # Allow up to 20% of elements to die per step
  starting_density_threshold: 0.02 # Starting cutoff value
  final_density_threshold: 0.90
  exponent_for_cutoff_schedule: 1.0 # Controls how fast the cutoff rises (Lower = Faster rise)
  # ---------------------------------------------------------

  # FILTER RADIUS (Decay Faster)
  minimum_feature_size_physical: 0.1
  minimum_feature_size_elements: 1.5 

  radius_max_multiplier: 1.0 
  radius_min_multiplier: 1.0  
  radius_decay_exponent: 0.8  # Drop radius quickly to allow fine details
  
 

# ------------------------------------------------------------------------------
# STRESS CONTROLLER SETTINGS
# ------------------------------------------------------------------------------
# PID and logic parameters for the adaptive stress constraint controller
stress_controller:
  Kp: 0.02
  Ki: 0.005
  integral_error_limit: 50.0        # Clamp for integral windup (-50, +50)
  max_adjustment_pct: 0.05          # Max adjustment per iter (+/- 5%)
  state_switch_error_low: 0.05      # 5% error threshold to trigger Relaxing
  state_switch_error_high: 0.15     # 15% error threshold (if variance is high)
  min_variance_for_switch: 0.25     # Min stress variance to allow high-error switch
  metric_percentile: 0.95           # Percentile for stress metric (95th)

# ------------------------------------------------------------------------------
# SOLVER PARAMETERS
# ------------------------------------------------------------------------------
solver_parameters:
  solver_type: gpu              
  preconditioner: "multigrid"
  tolerance: 1.e-6 
  max_iterations: 30000 
  diagonal_shift_factor: 1.e-7 
  stagnation_tolerance: 1.0e-3
  max_shift_attempts: 7
  shift_multiplier: 10.0
  gpu_method: krylov        
  krylov_solver: cg               

# ------------------------------------------------------------------------------
# OUTPUT SETTINGS
# ------------------------------------------------------------------------------
output_settings:
  export_frequency: 1        
  save_bin_frequency: 1     
  save_STL_frequency: 1     
  save_VTK_frequency: 1     
  save_principal_stress_vectors: yes
  save_displacement_vectors: yes
  log_filename: 00_simulation_log.txt
  iso_surface_threshold: 0.01
  stl_subdivision_level: 0        
  stl_smoothing_passes: 1         
  stl_mesh_smoothing_iters: 3     
  maximum_cells_in_binary_output: 25_000_000
  stl_target_triangle_count: 500000
"// # FILE: .\configs\solver_settings_4.yaml";
# FILE: .\configs\solver_settings.yaml
# ==============================================================================
# PART 2: NUMERICAL SOLVER & OPTIMIZATION SETTINGS
# ==============================================================================

# ------------------------------------------------------------------------------
# HARDWARE PROFILE
# ------------------------------------------------------------------------------
gpu_profile: "RTX" 

# ------------------------------------------------------------------------------
# RESTART CONFIGURATION
# ------------------------------------------------------------------------------
restart_configuration:
  enable_restart: false
  file_path: ""

# ------------------------------------------------------------------------------
# MESH & ADAPTIVITY SETTINGS
# ------------------------------------------------------------------------------
mesh_settings:
  initial_ground_mesh_size: 25_000_000
  final_target_of_active_elements: 25_000_000
  
  max_growth_rate: 1.1
  nominal_refinement_threshold: 0.9
  # exponent_for_refinement_schedule REMOVED (Unused)
  max_background_elements: 800_000_000
  gpu_solver_safety_factor: 0.95

# ------------------------------------------------------------------------------
# OPTIMIZATION LOOP
# ------------------------------------------------------------------------------
number_of_iterations: auto
hard_stop_after_iteration: 200

optimization_parameters:
  density_update_method: "hard"

  min_density: 0.0001
  density_clamp_max: 1
  
  # AGGRESSIVE CULLING CONFIGURATION
  # ---------------------------------------------------------
  max_culling_ratio: 0.20    # Allow up to 20% of elements to die per step
  starting_density_threshold: 0.02 # Starting cutoff value
  final_density_threshold: 0.90
  exponent_for_cutoff_schedule: 1.0 # Controls how fast the cutoff rises (Lower = Faster rise)
  # ---------------------------------------------------------

  # FILTER RADIUS (Decay Faster)
  minimum_feature_size_physical: 0.1
  minimum_feature_size_elements: 1.5 

  radius_max_multiplier: 1.0 
  radius_min_multiplier: 1.0  
  radius_decay_exponent: 0.8  # Drop radius quickly to allow fine details
  
 

# ------------------------------------------------------------------------------
# STRESS CONTROLLER SETTINGS
# ------------------------------------------------------------------------------
# PID and logic parameters for the adaptive stress constraint controller
stress_controller:
  Kp: 0.02
  Ki: 0.005
  integral_error_limit: 50.0        # Clamp for integral windup (-50, +50)
  max_adjustment_pct: 0.05          # Max adjustment per iter (+/- 5%)
  state_switch_error_low: 0.05      # 5% error threshold to trigger Relaxing
  state_switch_error_high: 0.15     # 15% error threshold (if variance is high)
  min_variance_for_switch: 0.25     # Min stress variance to allow high-error switch
  metric_percentile: 0.95           # Percentile for stress metric (95th)

# ------------------------------------------------------------------------------
# SOLVER PARAMETERS
# ------------------------------------------------------------------------------
solver_parameters:
  solver_type: gpu              
  preconditioner: "multigrid"
  tolerance: 1.e-6 
  max_iterations: 30000 
  diagonal_shift_factor: 1.e-7 
  stagnation_tolerance: 1.0e-3
  max_shift_attempts: 7
  shift_multiplier: 10.0
  gpu_method: krylov        
  krylov_solver: cg               

# ------------------------------------------------------------------------------
# OUTPUT SETTINGS
# ------------------------------------------------------------------------------
output_settings:
  export_frequency: 1        
  save_bin_frequency: 1     
  save_STL_frequency: 1     
  save_VTK_frequency: 1     
  save_principal_stress_vectors: yes
  save_displacement_vectors: yes
  log_filename: 00_simulation_log.txt
  iso_surface_threshold: 0.01
  stl_subdivision_level: 0        
  stl_smoothing_passes: 1         
  stl_mesh_smoothing_iters: 3     
  maximum_cells_in_binary_output: 25_000_000
  stl_target_triangle_count: 500000
"// # FILE: .\configs\wall_definition.yaml";
# FILE: .\configs\domain_definitions.yaml
# ==============================================================================
# PART 1: PHYSICAL PROBLEM DEFINITION
# ==============================================================================
# This file contains the "What": Geometry, Loads, BCs, and Materials.


# ------------------------------------------------------------------------------
# GEOMETRY DEFINITION
# ------------------------------------------------------------------------------
geometry:
  length_x: 60
  length_y: 40
  length_z: 10
  sphere1:
    type: sphere
    center: [12.51, 28.49, 7.45]
    diameter: 8
    stiffness_ratio: 0
  sphere2:
    type: sphere
    center: [38.87, 11.72, 1.88]
    diameter: 12
    stiffness_ratio: 10
  sphere3:
    type: sphere
    center: [22.52, 5, -2.37]
    diameter: 4
    stiffness_ratio: -10
  box1:
    type: box
    center: [28, 15, 7.07]
    size: [1, 2, 3]
    stiffness_ratio: 5
  box2:
    type: box
    center: [45.06, 8.95, 9.94]
    size: [12, 11, 2]
    stiffness_ratio: 0

# ------------------------------------------------------------------------------
# BOUNDARY CONDITIONS
# ------------------------------------------------------------------------------
boundary_conditions:
  - location: [0, ':', ':']
    DoFs: [1, 3]
  - location: [100%, 0%, ':']
    DoFs: [1, 2, 3]

# ------------------------------------------------------------------------------
# EXTERNAL FORCES
# ------------------------------------------------------------------------------
external_forces:
  - name: Mid_Y20
    location: [3, 40, 5]
    F: [0, -15, 0]

# ------------------------------------------------------------------------------
# MATERIAL PROPERTIES
# ------------------------------------------------------------------------------
material:
  E: 1
  nu: 0.3
  material_density: 0.001
  gravity_acceleration: 9.81
  delta_temperature: 0
  l1_stress_allowable: 1.5
"// # FILE: .\configs\archive\old_optimization_cases.yaml";
# FILE: .\configs\optimization_cases.yaml
# ==============================================================================
# OPTIMIZATION CASES ORCHESTRATOR
# ==============================================================================
# This file defines a sequence of simulations to run. 
# It merges a physics definition with a solver definition for each run.
#
# HOW TO USE OVERRIDES:
# You can add an 'overrides' section to any job to change specific parameters
# without creating a whole new config file. The structure must match the 
# nesting of the original config files.

batch_queue:
  # ----------------------------------------------------------------------------
  # Run 1: Baseline (Uses files exactly as they are)
  # ----------------------------------------------------------------------------
  - job_name: "Case_1_Baseline"
    domain_config: "./configs/domain_definitions.yaml"
    solver_config: "./configs/solver_settings.yaml"

  # ----------------------------------------------------------------------------
  # Run 2: High Resolution Test (Override Mesh Settings)
  # ----------------------------------------------------------------------------
  - job_name: "Case_2_HighRes"
    domain_config: "./configs/domain_definitions.yaml"
    solver_config: "./configs/solver_settings.yaml"
    overrides:
      mesh_settings:
        initial_ground_mesh_size: 2_000_000
        final_target_of_active_elements: 10_000_000
        max_growth_rate: 1.2

  # ----------------------------------------------------------------------------
  # Run 3: Aggressive Culling (Override Optimization Parameters)
  # ----------------------------------------------------------------------------
  - job_name: "Case_3_Aggressive"
    domain_config: "./configs/domain_definitions.yaml"
    solver_config: "./configs/solver_settings.yaml"
    overrides:
      optimization_parameters:
        max_culling_ratio: 0.30        # Increase culling speed
        density_update_method: "soft"  # Change update logic
        radius_max_multiplier: 5.0     # Larger start radius

  # ----------------------------------------------------------------------------
  # Run 4: Stiffer Material (Override Physics/Domain Definitions)
  # ----------------------------------------------------------------------------
  - job_name: "Case_4_Steel"
    domain_config: "./configs/domain_definitions.yaml"
    solver_config: "./configs/solver_settings.yaml"
    overrides:
      material:
        E: 210.0  # Change Young's Modulus
        nu: 0.28  # Change Poisson's Ratio
      external_forces:
        # Note: Overriding lists usually replaces the whole list
        - name: "Force_Overridden"
          location: [100%, 0, 0]
          F: [0, 500, 0]
"// # FILE: .\configs\archive\optimization_cases.yaml";
# FILE: .\configs\optimization_cases.yaml
# ==============================================================================
# OPTIMIZATION CASES ORCHESTRATOR
# ==============================================================================
# This file defines a sequence of simulations to run. 
# It merges a physics definition with a solver definition for each run.

batch_queue:
  # ----------------------------------------------------------------------------
  # Run 1: Standard RTX configuration
  # ----------------------------------------------------------------------------
  - job_name: "Case_1"
    domain_config: "./configs/domain_definitions.yaml"
    solver_config: "./configs/solver_settings_1.yaml"

"// # FILE: .\src\Main.jl";


using Pkg
using LinearAlgebra
using SparseArrays
using Printf
using Base.Threads
using JSON
using Dates
using Statistics
using CUDA
using YAML

println("\n>>> SCRIPT START: Loading Modules...")
flush(stdout)

const PROJECT_ROOT = abspath(joinpath(@__DIR__, ".."))
const LIMITS_FILE = joinpath(PROJECT_ROOT, "configs", "_machine_limits.jl")

if isfile(LIMITS_FILE)
    include(LIMITS_FILE)
else
    @eval module MachineLimits
        const MAX_GMG_ELEMENTS = 5_000_000
        const MAX_JACOBI_ELEMENTS = 10_000_000
    end
end

module HEXA
    using LinearAlgebra
    using SparseArrays
    using Printf
    using Base.Threads
    using JSON
    using Dates
    using Statistics
    using CUDA
    using YAML
    using ..MachineLimits

    const C_RESET   = "\u001b[0m"
    const C_BOLD    = "\u001b[1m"
    const C_RED     = "\u001b[31m"
    const C_GREEN   = "\u001b[32m"
    const C_YELLOW  = "\u001b[33m"
    const C_BLUE    = "\u001b[34m"
    const C_MAGENTA = "\u001b[35m"
    const C_CYAN    = "\u001b[36m"
    const C_ORANGE  = "\u001b[38;5;208m"

    const PROJECT_ROOT = abspath(joinpath(@__DIR__, ".."))

    
    include("Utils/Diagnostics.jl")
    include("Utils/Helpers.jl")
    using .Diagnostics
    using .Helpers

    
    include("Core/Element.jl")
    include("Core/Boundary.jl")
    include("Core/Stress.jl")
    using .Element
    using .Boundary
    using .Stress

    
    include("Mesh/Mesh.jl")
    include("Mesh/MeshUtilities.jl")
    include("Mesh/MeshPruner.jl")
    include("Mesh/MeshRefiner.jl")
    include("Mesh/MeshShapeProcessing.jl")
    using .Mesh
    using .MeshUtilities
    using .MeshPruner
    using .MeshRefiner
    using .MeshShapeProcessing

    
    include("Solvers/CPUSolver.jl")
    include("Solvers/GPUGeometricMultigrid.jl")
    include("Solvers/GPUSolver.jl")
    include("Solvers/DirectSolver.jl")
    include("Solvers/IterativeSolver.jl")
    include("Solvers/Solver.jl")
    
    using .CPUSolver
    using .GPUGeometricMultigrid
    using .GPUSolver
    using .DirectSolver
    using .IterativeSolver
    using .Solver

    
    include("IO/Configuration.jl")
    include("IO/ExportVTK.jl")
    include("IO/Postprocessing.jl")
    
    
    include("Optimization/GPUExplicitFilter.jl")
    include("Optimization/TopOpt.jl")
    
    using .Configuration
    using .ExportVTK
    using .Postprocessing
    using .GPUExplicitFilter
    using .TopologyOptimization

    
    include("App/HardwareProfile.jl")
    include("App/SimulationLoop.jl")
    include("App/BatchProcessor.jl")

    using .HardwareProfile
    using .SimulationLoop
    using .BatchProcessor

    function __init__()
        Diagnostics.print_success("HEXA Finite Element Solver initialized")
        Helpers.clear_gpu_memory()
        flush(stdout)
    end
    
    function run(input_file=nothing)
        BatchProcessor.process_batch(input_file, PROJECT_ROOT)
    end

end

function bootstrap()
    println(">>> [BOOTSTRAP] Parsing arguments and launching module...")
    flush(stdout)
    
    config_file = nothing
    if length(ARGS) >= 1
        config_file = ARGS[1]
    end

    HEXA.run(config_file)
end

bootstrap()
"// # FILE: .\src\App\BatchProcessor.jl";

module BatchProcessor

using CUDA
using ..Configuration
using ..Diagnostics
using ..Helpers
using ..SimulationLoop

export process_batch

function process_batch(input_file=nothing, project_root::String="")
    try
        if input_file === nothing
            input_file = joinpath(project_root, "configs", "optimization_cases.yaml")
        end
        
        if !isfile(input_file)
            error("Input file not found: $input_file")
        end

        raw_config = Configuration.load_configuration(input_file)

        if haskey(raw_config, "batch_queue")
            queue = raw_config["batch_queue"]
            Diagnostics.print_banner("BATCH EXECUTION STARTED: $(length(queue)) Runs")
            
            for (i, run_def) in enumerate(queue)
                job_name = get(run_def, "job_name", "Run_$i")
                Diagnostics.print_banner("BATCH RUN $i/$((length(queue))): $job_name", color="\u001b[35m")
                
                domain_file = get(run_def, "domain_config", "")
                solver_file = get(run_def, "solver_config", "")
                overrides = get(run_def, "overrides", Dict())

                if isempty(domain_file) || isempty(solver_file)
                    Diagnostics.print_error("Skipping $job_name: Missing config file paths.")
                    continue
                end

                if !isabspath(domain_file); domain_file = joinpath(project_root, domain_file); end
                if !isabspath(solver_file); solver_file = joinpath(project_root, solver_file); end

                try
                    merged_config = Configuration.load_and_merge_configurations(domain_file, solver_file, overrides)
                    SimulationLoop.run_simulation(merged_config, job_name; project_root=project_root)
                catch e_run
                    Diagnostics.print_error("Job $job_name Failed: $e_run")
                    showerror(stdout, e_run, catch_backtrace())
                end
                
                Diagnostics.print_success("Finished Batch Run: $job_name")
                GC.gc()
                if CUDA.functional(); CUDA.reclaim(); end
            end
            Diagnostics.print_banner("BATCH QUEUE COMPLETE")

        else
            base_job_name = get(raw_config, "job_name", splitext(basename(input_file))[1])
            SimulationLoop.run_simulation(raw_config, base_job_name; project_root=project_root)
        end

    catch e
        if isa(e, InterruptException)
            Diagnostics.print_banner("USER INTERRUPT", color="\u001b[33m")
            println(">>> Simulation stopped by user.")
        else
            Diagnostics.print_banner("FATAL ERROR DETECTED", color="\u001b[31m")
            showerror(stderr, e, catch_backtrace())
        end
        flush(stdout)
    finally
        if CUDA.functional()
            Diagnostics.print_info("Finalizing: Cleaning up GPU Memory...")
            Helpers.clear_gpu_memory()
            Diagnostics.print_success("GPU Memory Released.")
            flush(stdout)
        end
    end
end

end
"// # FILE: .\src\App\HardwareProfile.jl";

module HardwareProfile

using CUDA
using ..Diagnostics
using ..MachineLimits

export apply_hardware_profile!

function apply_hardware_profile!(config::Dict)
    gpu_type = get(config, "gpu_profile", "RTX")
    if gpu_type == "AUTO" && CUDA.functional()
        dev_name = CUDA.name(CUDA.device())
        if occursin("V100", dev_name); gpu_type = "V100"; end
        if occursin("A100", dev_name) || occursin("H100", dev_name); gpu_type = "H200"; end
        Diagnostics.print_info("Auto-Detected GPU: $dev_name -> Profile: $gpu_type")
    else
        Diagnostics.print_info("Using Configured Profile: $gpu_type")
    end
    
    mesh_conf = get(config, "mesh_settings", Dict())
    solver = get(config, "solver_parameters", Dict())
    
    config["force_float64"] = false
    if uppercase(gpu_type) in ["H", "H200", "H100", "A100"]
        Diagnostics.print_substep("High-Performance Data Center GPU (H/A-Series). Precision: Float64.")
        solver["tolerance"] = get(solver, "tolerance", 1.0e-12)
        solver["diagonal_shift_factor"] = 1.0e-10
        solver["solver_type"] = "gpu"
        config["force_float64"] = true
    elseif uppercase(gpu_type) == "V100"
        Diagnostics.print_substep("Legacy Data Center GPU (Tesla V100). Precision: Float64.")
        solver["tolerance"] = get(solver, "tolerance", 1.0e-10)
        solver["diagonal_shift_factor"] = 1.0e-9
        solver["solver_type"] = "gpu"
        config["force_float64"] = true
    else 
        Diagnostics.print_substep("Consumer/Workstation GPU (RTX-Series). Precision: Float32.")
        solver["tolerance"] = get(solver, "tolerance", 1.0e-6)
        solver["solver_type"] = "gpu"
        config["force_float64"] = false
    end
    config["mesh_settings"] = mesh_conf
    config["solver_parameters"] = solver
    config["hardware_profile_applied"] = gpu_type
    
    config["machine_limits"] = Dict(
        "MAX_GMG_ELEMENTS" => MachineLimits.MAX_GMG_ELEMENTS,
        "MAX_JACOBI_ELEMENTS" => MachineLimits.MAX_JACOBI_ELEMENTS
    )
end

end
"// # FILE: .\src\App\SimulationLoop.jl";
// # FILE: .\src\App\SimulationLoop.jl";


module SimulationLoop

using LinearAlgebra
using Printf
using Base.Threads
using Dates
using Statistics
using CUDA


using ..Diagnostics
using ..Helpers
using ..Configuration
using ..Boundary
using ..Element
using ..Stress
using ..Mesh
using ..MeshRefiner
using ..Solver
using ..Postprocessing
using ..TopologyOptimization
using ..HardwareProfile

export run_simulation

function run_simulation(current_config::Dict, run_name::String="Simulation"; project_root::String="")
    Diagnostics.print_banner("HEXA TOPOLOGY OPTIMIZER: $run_name")
    Diagnostics.print_info("Clearing GPU Memory from previous runs...")
    
    if CUDA.functional()
        Helpers.clear_gpu_memory()
        CUDA.device!(0) 
        dev = CUDA.device()
        name = CUDA.name(dev)
        total_mem = CUDA.total_memory()
        mem_gb = total_mem / 1024^3
        Diagnostics.print_success("GPU Detected: $name ($(round(mem_gb, digits=2)) GB)")
    end
    GC.gc()
    
    HardwareProfile.apply_hardware_profile!(current_config)
    
    restart_conf = get(current_config, "restart_configuration", Dict())
    enable_restart = get(restart_conf, "enable_restart", false)
    restart_path = get(restart_conf, "file_path", "")
    
    config = Dict{Any,Any}()
    density = Float32[]
    start_iter = 1
    restart_radius = 0.0f0
    restart_threshold = 0.0f0
    integral_error = 0.0f0
    U_full = Float32[] 
    is_restart_active = false

    if enable_restart && isfile(restart_path)
         Diagnostics.print_banner("RESTART MODE ACTIVE", color="\u001b[35m")
         saved_config, density_dummy, U_loaded, i_err, saved_iter, restart_radius, restart_threshold = Configuration.load_checkpoint(restart_path)
         config = merge(saved_config, current_config)
         HardwareProfile.apply_hardware_profile!(config)
         start_iter = saved_iter + 1
         integral_error = i_err
         is_restart_active = true
    else
         config = current_config
         is_restart_active = false
    end
    
    hard_stop_iter = get(config, "hard_stop_after_iteration", -1)

    out_settings = get(config, "output_settings", Dict())
    default_freq = get(out_settings, "export_frequency", 5)
    save_bin_freq = get(out_settings, "save_bin_frequency", default_freq)
    save_stl_freq = get(out_settings, "save_STL_frequency", default_freq)
    save_vtk_freq = get(out_settings, "save_VTK_frequency", default_freq)

    save_vec_val = get(out_settings, "save_principal_stress_vectors", "no")
    save_vectors_bool = (lowercase(string(save_vec_val)) == "yes" || save_vec_val == true)
    
    RESULTS_DIR = joinpath(project_root, "RESULTS", run_name)
    if !isdir(RESULTS_DIR); mkpath(RESULTS_DIR); end
    Diagnostics.print_info("Output Directory: $RESULTS_DIR")

    raw_log_name = get(out_settings, "log_filename", "simulation_log.txt")
    log_base, log_ext = splitext(basename(raw_log_name))
    log_filename = joinpath(RESULTS_DIR, "$(log_base)_$(run_name)$(log_ext)")
    
    iso_threshold_val = get(out_settings, "iso_surface_threshold", 0.01)
    iso_threshold = Float32(iso_threshold_val)
    
    if !is_restart_active
        Diagnostics.init_log_file(log_filename, config)
    else
        Diagnostics.log_status("--- RESTARTING SIMULATION (Iter $start_iter) ---")
    end
    
    geom = Configuration.setup_geometry(config)
    nodes, elements, dims = generate_mesh(geom.nElem_x, geom.nElem_y, geom.nElem_z; dx = geom.dx, dy = geom.dy, dz = geom.dz)
    initial_target_count = size(elements, 1)
    
    domain_bounds = (min_pt=[0.0f0,0.0f0,0.0f0], len_x=geom.dx*geom.nElem_x, len_y=geom.dy*geom.nElem_y, len_z=geom.dz*geom.nElem_z)
    config["geometry"]["nElem_x_computed"] = geom.nElem_x
    config["geometry"]["nElem_y_computed"] = geom.nElem_y
    config["geometry"]["nElem_z_computed"] = geom.nElem_z
    config["geometry"]["dx_computed"] = geom.dx
    config["geometry"]["dy_computed"] = geom.dy
    config["geometry"]["dz_computed"] = geom.dz
    config["geometry"]["max_domain_dim"] = geom.max_domain_dim
    
    nNodes = size(nodes, 1)
    ndof = nNodes * 3
    
    if length(U_full) != ndof
        U_full = zeros(Float32, ndof)
    end

    bc_data = config["boundary_conditions"]
    forces_data = config["external_forces"]
    
    bc_indicator = Boundary.get_bc_indicator(nNodes, nodes, Vector{Any}(bc_data))
    F_external = zeros(Float32, ndof)
    Boundary.apply_external_forces!(F_external, Vector{Any}(forces_data), nodes, elements)
    Diagnostics.print_success("Boundary Conditions & External Forces Mapped.")

    E = Float32(config["material"]["E"])
    nu = Float32(config["material"]["nu"])
    
    
    # material_density = Float32(get(config["material"], "material_density", 0.0)) 
    
    gravity_accel = Float32(get(config["material"], "gravity_acceleration", 9.81))
    delta_T = Float32(get(config["material"], "delta_temperature", 0.0))
    if abs(delta_T) > 1e-6; Diagnostics.print_info("THERMOELASTICITY ENABLED: Delta T = $delta_T"); end

    original_density = ones(Float32, size(elements, 1)) 
    protected_elements_mask = falses(size(elements, 1)) 
    alpha_field = zeros(Float32, size(elements, 1))
    mass_density_field = zeros(Float32, size(elements, 1))

    
    density, original_density, protected_elements_mask, alpha_field, mass_density_field = Configuration.initialize_density_field(nodes, elements, geom.shapes, config)
    
    opt_params = config["optimization_parameters"]
    min_density = Float32(get(opt_params, "min_density", 1.0e-3))
    max_density_clamp = Float32(get(opt_params, "density_clamp_max", 1.0))
    max_culling_ratio = Float32(get(opt_params, "max_culling_ratio", 0.05))
    base_name = run_name 
    
    mesh_conf = get(config, "mesh_settings", Dict())
    
    nElem = size(elements, 1)
    estimated_iters = Helpers.estimate_required_iterations(config, nElem)
    
    nominal_iters_conf = get(config, "number_of_iterations", "AUTO")
    max_planned_iterations = 200 

    if nominal_iters_conf == "AUTO" || nominal_iters_conf == "auto"
        max_planned_iterations = estimated_iters
        Diagnostics.print_banner("AUTO-SCHEDULING")
        println("      > Calculated:        $estimated_iters iterations")
        println("      > Final Setting:  $max_planned_iterations iterations")
    else
        user_iters = Int(nominal_iters_conf)
        max_planned_iterations = user_iters
    end
    
    raw_active_target = get(mesh_conf, "final_target_of_active_elements", initial_target_count)
    final_target_active = isa(raw_active_target, String) ? parse(Int, replace(raw_active_target, "_" => "")) : Int(raw_active_target)
    max_growth_rate = Float64(get(mesh_conf, "max_growth_rate", 1.2))
    raw_bg_limit = get(mesh_conf, "max_background_elements", 800_000_000)
    hard_elem_limit = isa(raw_bg_limit, String) ? parse(Int, replace(raw_bg_limit, "_" => "")) : Int(raw_bg_limit)
    Diagnostics.print_info("Hard Element Limit: $(Base.format_bytes(hard_elem_limit * 100)) approx ($hard_elem_limit elems)")

    
    mat_config = config["material"]
    l1_stress_default = Float32(get(mat_config, "l1_stress_allowable", 1.0))
    
    limit_tension = Float32(get(mat_config, "l1_stress_allowable_tension", l1_stress_default))
    limit_compression = Float32(get(mat_config, "l1_stress_allowable_compression", l1_stress_default))
    
    Diagnostics.print_info("STRESS LIMITS:")
    println("      > Tension:      $limit_tension")
    println("      > Compression: $limit_compression")
    
    target_metric_val = 1.0f0 
    
    STABILITY_TARGET = Float64(get(opt_params, "convergence_stability_tolerance", 0.002))
    STRESS_ACCURACY_TARGET = Float64(get(opt_params, "convergence_stress_error_tolerance", 0.01))
    CONSECUTIVE_ITERS_REQUIRED = Int(get(opt_params, "convergence_required_streak", 5))
    
    update_damping_exp = Float32(get(opt_params, "update_damping_exponent", 1.0))
    
    Diagnostics.print_info("CONTROL MODE: Accelerated Stress Controller (Adaptive Cutoff)")
    
    
    internal_safety_factor = 1.0f0
    
    ctrl_conf = get(config, "stress_controller", Dict())
    Kp = Float32(get(ctrl_conf, "Kp", 0.02))
    Ki = Float32(get(ctrl_conf, "Ki", 0.005))
    integral_error_limit = Float32(get(ctrl_conf, "integral_error_limit", 50.0))
    max_adj_pct = Float32(get(ctrl_conf, "max_adjustment_pct", 0.05))
    state_switch_low = Float32(get(ctrl_conf, "state_switch_error_low", 0.05))
    state_switch_high = Float32(get(ctrl_conf, "state_switch_error_high", 0.15))
    min_var_switch = Float32(get(ctrl_conf, "min_variance_for_switch", 0.25))
    metric_percentile = Float64(get(ctrl_conf, "metric_percentile", 0.95))
    
    avg_element_size = (geom.dx + geom.dy + geom.dz) / 3.0f0
    target_d_phys = Float32(get(opt_params, "minimum_feature_size_physical", 0.0))
    floor_d_elems = Float32(get(opt_params, "minimum_feature_size_elements", 3.0)) 
    d_min_phys = max(target_d_phys, floor_d_elems * avg_element_size)
    
    current_radius = is_restart_active ? restart_radius : (d_min_phys * 4.0f0)
    
    starting_cutoff = Float32(get(opt_params, "starting_density_threshold", 0.10))
    current_cutoff = starting_cutoff
    
    R_min_val = d_min_phys * 1.0f0

    cutoff_state = 0 
    frozen_cutoff_counter = 0 
    current_stress_variance = 1.0f0
    
    iter = start_iter
    keep_running = true
    
    prev_density = copy(density)
    last_valid_density = copy(density) 
    prev_compliance = Inf 
    
    stability_metric = 1.0
    consecutive_converged_iters = 0
    
    relaxing_error_trend = 0.0f0
    prev_metric_error = 0.0f0

    Diagnostics.print_banner("STARTING MAIN LOOP")
    Diagnostics.print_info("Log File: $log_filename")
    
    flush(stdout) 

    while keep_running
        iter_start_time = time()
        status_msg = "Optimizing"
        
        cur_dims_str = "$(config["geometry"]["nElem_x_computed"])x$(config["geometry"]["nElem_y_computed"])x$(config["geometry"]["nElem_z_computed"])"
        config["current_outer_iter"] = iter
        
        current_active = count(d -> d > 0.01, density)
        nominal_ref_thresh = Float64(get(mesh_conf, "nominal_refinement_threshold", 0.8))
        
        if current_active < (final_target_active * nominal_ref_thresh) && size(elements, 1) < final_target_active
             prev_elem_count = size(elements, 1)
             nodes, elements, density, alpha_field, mass_density_field, dims = MeshRefiner.refine_mesh_and_fields(
                nodes, elements, density, alpha_field, mass_density_field, dims, final_target_active, domain_bounds;
                max_growth_rate = max_growth_rate, hard_element_limit = hard_elem_limit
            )
            GC.gc()
            
            if size(elements, 1) > prev_elem_count
                status_msg = "Refined"
                consecutive_converged_iters = 0
                current_dx = domain_bounds.len_x / (dims[1]-1)
                avg_element_size = current_dx 
                d_min_phys = max(target_d_phys, floor_d_elems * avg_element_size)
                config["geometry"]["nElem_x_computed"] = dims[1]-1
                config["geometry"]["nElem_y_computed"] = dims[2]-1
                config["geometry"]["nElem_z_computed"] = dims[3]-1
                config["geometry"]["dx_computed"] = current_dx
                config["geometry"]["dy_computed"] = domain_bounds.len_y / (dims[2]-1)
                config["geometry"]["dz_computed"] = domain_bounds.len_z / (dims[3]-1)
                
                geom = (nElem_x=dims[1]-1, nElem_y=dims[2]-1, nElem_z=dims[3]-1, 
                        dx=config["geometry"]["dx_computed"], dy=config["geometry"]["dy_computed"], dz=config["geometry"]["dz_computed"], 
                        shapes=geom.shapes, actual_elem_count=size(elements, 1), max_domain_dim=geom.max_domain_dim)

                Diagnostics.print_substep("[Refinement] Re-mapping Boundary Conditions & Forces...")
                nNodes = size(nodes, 1)
                ndof = nNodes * 3
                bc_indicator = Boundary.get_bc_indicator(nNodes, nodes, Vector{Any}(config["boundary_conditions"]))
                F_external = zeros(Float32, ndof)
                Boundary.apply_external_forces!(F_external, Vector{Any}(config["external_forces"]), nodes, elements)
                
                
                _, original_density, protected_elements_mask, _, _ = Configuration.initialize_density_field(nodes, elements, geom.shapes, config)
                
                U_full = zeros(Float32, ndof)
                TopologyOptimization.reset_filter_cache!()
                prev_density = copy(density)
                last_valid_density = copy(density) 
                prev_compliance = Inf
                cutoff_state = 0 
                relaxing_error_trend = 0.0f0 
            end
        end

        Threads.@threads for e in 1:size(elements, 1)
            if protected_elements_mask[e]; density[e] = original_density[e]; end
        end
        
        F_total = copy(F_external)
        
        
        if gravity_accel != 0.0
             Boundary.add_self_weight!(F_total, density, mass_density_field, protected_elements_mask, 1.0f0, elements, geom.dx, geom.dy, geom.dz, gravity_accel)
        end
        
        
        if abs(delta_T) > 1e-6
             Boundary.compute_global_thermal_forces!(F_total, nodes, elements, alpha_field, delta_T, E, nu, density)
        end
        
        C_ORANGE = "\u001b[38;5;208m"
        C_RESET = "\u001b[0m"
        C_YELLOW = "\u001b[33m"
        Diagnostics.print_substep("FEA Solve (Iter " * C_ORANGE * "$iter / $max_planned_iterations" * C_RESET * ")")
        
        sol_tuple = Solver.solve_system(
            nodes, elements, E, nu, bc_indicator, F_total;
            density=density, config=config, min_stiffness_threshold=min_density, 
            prune_voids=true, u_prev=U_full 
        )
        U_new = sol_tuple[1]
        last_residual = sol_tuple[2]
        prec_used = sol_tuple[3]
        U_full = U_new
        
        if CUDA.functional(); GC.gc(); CUDA.reclaim(); end
        
        compliance = dot(F_total, U_full)
        strain_energy = 0.5 * compliance
        
        
        elem_vol = geom.dx * geom.dy * geom.dz
        
        
        
        current_weight = 0.0
        for e in 1:length(density)
            if protected_elements_mask[e]
                current_weight += mass_density_field[e] * elem_vol
            else
                current_weight += density[e] * mass_density_field[e] * elem_vol
            end
        end
        
        
        
        
        if iter > 1 && compliance > (prev_compliance * 1.5)
            println(C_YELLOW * ">>> [BACKTRACK] Compliance spike detected. Stabilizing..." * C_RESET)
            density .= last_valid_density
            internal_safety_factor *= 0.75f0 
            integral_error = 0.0f0 
            cutoff_state = 0 
            relaxing_error_trend = 0.0f0 
            
            Diagnostics.write_iteration_log(
                log_filename, iter, cur_dims_str, length(density), current_active, 
                current_radius, current_cutoff, compliance, strain_energy, 0.0, 
                0.0, 0.0, "Backtrack", 0.0, last_residual, prec_used,
                stability_metric, 0.0, 0, 0.0, current_weight
            )
            iter += 1
            continue 
        end
        
        last_valid_density .= density
        prev_compliance = compliance
        
        Diagnostics.print_substep("Calculating Stress Field...")
        
        
        principal_field, vonmises_field, full_stress_voigt, l1_stress_norm_field, principal_max_dir_field, principal_min_dir_field = Stress.compute_stress_field(nodes, elements, U_full, E, nu, density; return_voigt=false)
        
        try
            if iter == 1
                Diagnostics.print_info("Exporting INITIAL REFERENCE STATE (Iter 0)...")
                do_bin_init = (save_bin_freq > 0); do_stl_init = (save_stl_freq > 0); do_vtk_init = (save_vtk_freq > 0)
                if do_bin_init || do_stl_init || do_vtk_init
                    Postprocessing.export_iteration_results(0, base_name, RESULTS_DIR, nodes, elements, U_full, F_total, bc_indicator, 
                                                            principal_field, vonmises_field, full_stress_voigt, l1_stress_norm_field, 
                                                            principal_max_dir_field, principal_min_dir_field, 
                                                            density, E, geom; 
                                                            iso_threshold=Float32(iso_threshold), 
                                                            current_radius=Float32(current_radius), 
                                                            integral_error=Float32(integral_error),
                                                            config=config, 
                                                            save_bin=do_bin_init, save_stl=do_stl_init, save_vtk=do_vtk_init)
                end
                if hard_stop_iter == 0; println(">>> HARD STOP: Stopping after background analysis (Iter 0)."); keep_running = false; break; end
            end
        catch e_export
            Diagnostics.print_warn("Initial export failed ($e_export).")
        end
        
        active_indices = findall(i -> density[i] > 0.1f0 && !protected_elements_mask[i], 1:length(density))
        
        current_metric_val = 0.0f0
        current_variance = 0.0f0
        
        if !isempty(active_indices)
            
            utilization_values = Vector{Float32}(undef, length(active_indices))
            
            for (i, idx) in enumerate(active_indices)
                raw_s = l1_stress_norm_field[idx]
                
                
                lim = (raw_s >= 0) ? limit_tension : limit_compression
                utilization_values[i] = abs(raw_s) / abs(lim)
            end
            
            sort!(utilization_values)
            n_vals = length(utilization_values)
            cutoff_idx = floor(Int, n_vals * metric_percentile)
            
            if cutoff_idx > 10
                subset = view(utilization_values, 1:cutoff_idx)
                current_metric_val = mean(subset)
                std_val = std(subset)
                if current_metric_val > 1e-6
                    current_variance = std_val / current_metric_val
                end
            else
                current_metric_val = 0.0f0
            end
        end

        
        metric_error = (current_metric_val - target_metric_val) / target_metric_val
        
        if cutoff_state == 0 
            if abs(metric_error) < state_switch_low
                cutoff_state = 1
                relaxing_error_trend = 0.0f0
            elseif (abs(metric_error) < state_switch_high) && (current_variance > min_var_switch)
                cutoff_state = 1
                relaxing_error_trend = 0.0f0
            end
        elseif cutoff_state == 1 
            if abs(metric_error) > 1.0f0
                cutoff_state = 0 
                relaxing_error_trend = 0.0f0
            end
            
            if abs(metric_error) > prev_metric_error
                relaxing_error_trend += 1.0f0
            else
                relaxing_error_trend = max(0.0f0, relaxing_error_trend - 0.5f0)
            end
            
            if relaxing_error_trend >= 5.0f0
                Diagnostics.print_warn(">>> [CONTROLLER] Relaxing Failed (Error Rising). Backing off.")
                cutoff_state = 0 
                current_cutoff = max(starting_cutoff, current_cutoff * 0.95f0) 
                integral_error *= 0.5f0 
                relaxing_error_trend = 0.0f0
            end
        end
        prev_metric_error = abs(metric_error)
        
        if cutoff_state == 1
            frozen_cutoff_counter += 1
            status_msg = "Relaxing ($frozen_cutoff_counter)"
        else
            frozen_cutoff_counter = 0
        end
        
        control_error = -metric_error 
        integral_error += control_error
        
        integral_error = clamp(integral_error, -integral_error_limit, integral_error_limit) 
        
        eff_Kp = (cutoff_state == 1) ? (Kp * 0.1f0) : Kp
        eff_Ki = Ki * 0.1f0
        
        adjustment_pct = (eff_Kp * control_error) + (eff_Ki * integral_error)
        
        adjustment_pct = clamp(adjustment_pct, -max_adj_pct, max_adj_pct)
        
        adjustment_factor = 1.0f0 + adjustment_pct
        internal_safety_factor *= adjustment_factor
        internal_safety_factor = clamp(internal_safety_factor, 0.1f0, 10.0f0)

        final_cutoff_target = Float32(get(opt_params, "final_density_threshold", 0.5))
        progress = Float32(iter) / Float32(max_planned_iterations)
        progress = clamp(progress, 0.0f0, 1.0f0)
        
        accel_factor = 1.0f0
        if metric_error < -0.2f0  
            accel_factor = 2.0f0  
        end
        
        base_cutoff_sched = starting_cutoff 
        cutoff_exponent = Float32(get(opt_params, "exponent_for_cutoff_schedule", 0.7)) 
        effective_progress = clamp(progress * accel_factor, 0.0f0, 1.0f0)
        target_scheduled_cutoff = base_cutoff_sched + (final_cutoff_target - base_cutoff_sched) * (effective_progress ^ cutoff_exponent) 
        
        if cutoff_state == 0 
            rise_limit = (metric_error < -0.2f0) ? 0.01f0 : 0.002f0
            if abs(metric_error) < 0.10f0; rise_limit = 0.0002f0; end
            current_cutoff = min(target_scheduled_cutoff, current_cutoff + rise_limit)
        end
        
        R_sched_val = d_min_phys * 4.0f0 + (d_min_phys * 1.0f0 - d_min_phys * 4.0f0) * ((progress)^2)
        
        if cutoff_state == 1
            current_radius = R_min_val
        else
            current_radius = R_sched_val
        end

        Diagnostics.print_substep("Controller Status:")
        println("      > Utilization:          $(round(current_metric_val * 100, digits=2))% (Target: 100%)")
        println("      > Safety Factor:        $(round(internal_safety_factor, digits=3))")
        println("      > Error:                $(round(metric_error * 100, digits=2))%")
        println("      > Cutoff Status:        $(cutoff_state == 1 ? "FROZEN (Relaxing)" : "RISING")")
        println("      > Current Cutoff:       $(round(current_cutoff, digits=3))")

        Diagnostics.print_substep("Topology Update & Filtering...")
        
        
        eff_limit_T = limit_tension * internal_safety_factor
        eff_limit_C = limit_compression * internal_safety_factor
        
        mean_change, _, actual_cutoff, filter_time, _, _ = TopologyOptimization.update_density!(
            density, l1_stress_norm_field, protected_elements_mask, E, eff_limit_T, eff_limit_C, 
            iter, max_planned_iterations, 
            original_density, min_density, max_density_clamp, config, elements; 
            force_no_cull = false,
            cutoff_threshold = current_cutoff,        
            specified_radius = current_radius,        
            max_culling_ratio = max_culling_ratio,
            update_damping = update_damping_exp
        )
        
        active_indices = findall(x -> x > min_density, density)
        n_active = length(active_indices)
        
        if n_active > 0
            changed_elements = count(i -> abs(density[i] - prev_density[i]) > 0.01, active_indices)
            stability_metric = Float64(changed_elements) / Float64(n_active)
        else
            stability_metric = 0.0
        end
        
        stress_metric = abs(metric_error)
        radius_converged = (current_radius <= (R_min_val * 1.05))
        variance_metric = current_variance
        
        is_currently_converged = (stability_metric < 0.005) && 
                                 (stress_metric < 0.05) && 
                                 (variance_metric < 0.25) &&
                                 radius_converged

        if is_currently_converged
            consecutive_converged_iters += 1
        else
            consecutive_converged_iters = 0
        end
        
        println(C_YELLOW * "    [Topo Opt Iter: $iter/$max_planned_iterations]" * C_RESET)
        println("      > Stability:  $(round(stability_metric*100, digits=2))% (Target < 0.5%)")
        println("      > Stress Err: $(round(stress_metric*100, digits=2))% (Target < 5.0%)")
        println("      > Stress Var: $(round(variance_metric*100, digits=2))% (Target < 25.0%)")
        println("      > Radius End: $(radius_converged ? "YES" : "NO") ($(round(current_radius,digits=3)) vs $(round(R_min_val,digits=3)))")
        println("      > Streak:          $consecutive_converged_iters / $CONSECUTIVE_ITERS_REQUIRED steps")
        
        prev_density = copy(density)
        iter_time = time() - iter_start_time
        vol_total = length(density)
        vol_frac = sum(density)/vol_total
        
        Diagnostics.write_iteration_log(
            log_filename, iter, cur_dims_str, vol_total, n_active, 
            current_radius, current_cutoff, compliance, strain_energy, current_metric_val, 
            vol_frac, mean_change, status_msg, iter_time, last_residual, prec_used,
            stability_metric, stress_metric, consecutive_converged_iters, variance_metric,
            current_weight
        )

        is_last_iter = (!keep_running) || (hard_stop_iter > 0 && iter >= hard_stop_iter)
        
        if consecutive_converged_iters >= CONSECUTIVE_ITERS_REQUIRED
            Diagnostics.print_success("EARLY CONVERGENCE REACHED (Stable for $consecutive_converged_iters steps)!")
            keep_running = false
            is_last_iter = true
        end
        
        if keep_running && iter >= max_planned_iterations
            if max_planned_iterations < 1000 
                Diagnostics.print_warn("Target iterations reached but NOT converged. Extending simulation by 50 iterations.")
                max_planned_iterations += 50
            else
                Diagnostics.print_error("Hard iteration limit (1000) reached. Stopping simulation.")
                keep_running = false
                is_last_iter = true
            end
        end
        
        do_bin = (save_bin_freq > 0) && (iter % save_bin_freq == 0)
        do_stl = ((save_stl_freq > 0) && (iter % save_stl_freq == 0)) || is_last_iter
        do_vtk = (save_vtk_freq > 0) && (iter % save_vtk_freq == 0)
        
        should_export = do_bin || do_stl || do_vtk || is_last_iter 

        if should_export
            Diagnostics.print_substep("Exporting results...")
            try
                Postprocessing.export_iteration_results(iter, base_name, RESULTS_DIR, nodes, elements, U_full, F_total, bc_indicator, 
                                                        principal_field, vonmises_field, full_stress_voigt, l1_stress_norm_field, 
                                                        principal_max_dir_field, principal_min_dir_field, 
                                                        density, E, geom; 
                                                        iso_threshold=Float32(iso_threshold), 
                                                        current_radius=Float32(current_radius), 
                                                        integral_error=Float32(integral_error),
                                                        config=config, 
                                                        save_bin=do_bin, save_stl=do_stl, save_vtk=do_vtk)
            catch e_export
                Diagnostics.print_error("Post-processing failed at Iter $iter. Logged to crash_report.")
            end
        end
        
        if hard_stop_iter > 0 && iter >= hard_stop_iter; println(">>> HARD STOP: Reached target iteration $hard_stop_iter."); keep_running = false; break; end
        
        if CUDA.functional(); Helpers.clear_gpu_memory(); end
        iter += 1
        GC.gc()
        flush(stdout) 
    end
    Diagnostics.log_status("Finished.")
end

end
"// # FILE: .\src\Core\Boundary.jl";
// # FILE: .\src\Core\Boundary.jl";


module Boundary 

using JSON 
using SparseArrays 
using LinearAlgebra 
using Base.Threads
using ..Element

export get_bc_indicator, reduce_system, apply_external_forces!, add_self_weight!, compute_global_thermal_forces!

""" 
    get_affected_nodes(spec, nodes) 

Returns an array of *final* node indices affected by this BC specification `spec`. 
""" 
function get_affected_nodes(spec::AbstractDict, nodes::Matrix{Float32}) 
      
    nNodes = size(nodes, 1) 

    # 1) If user gave "node" 
    if haskey(spec, "node") 
        raw = spec["node"] 
        if isa(raw, Integer) 
            idx = clamp(raw, 1, nNodes) 
            return [idx] 
        elseif isa(raw, AbstractVector) 
            node_list = Int[] 
            for r in raw 
                push!(node_list, clamp(r, 1, nNodes)) 
            end 
            return unique(node_list) 
        else 
            error("'node' must be an integer or an array of integers") 
        end 
    end 

    # 2) If user gave "location" 
    if haskey(spec, "location") 
        loc_array = spec["location"] 
        if length(loc_array) < 3 
            error("Location specification must have at least 3 components (x,y,z)") 
        end 
        return get_nodes_by_location(loc_array, nodes) 
    end 

    error("Specification must include either 'node' or 'location'") 
end 

""" 
    get_nodes_by_location(loc_array, nodes) 

Find nodes whose (x,y,z) coordinates match the "location" pattern. 
""" 
function get_nodes_by_location(loc_array::AbstractVector, nodes::Matrix{Float32}) 
    xvals = @view nodes[:, 1] 
    yvals = @view nodes[:, 2] 
    zvals = @view nodes[:, 3] 

    xmin, xmax = extrema(xvals) 
    ymin, ymax = extrema(yvals) 
    zmin, zmax = extrema(zvals) 

    xspec = loc_array[1] 
    yspec = loc_array[2] 
    zspec = loc_array[3] 

    xmask = interpret_location_component(xspec, xvals, xmin, xmax) 
    ymask = interpret_location_component(yspec, yvals, ymin, ymax) 
    zmask = interpret_location_component(zspec, zvals, zmin, zmax) 

    return findall(xmask .& ymask .& zmask) 
end 

""" 
    interpret_location_component(spec, coords, cmin, cmax) 

Robustly identifies nodes matching the spec.
Changes: Now finds the CLOSEST nodes to the target value if exact match fails.
This prevents empty selections when the mesh is coarse or misaligned.
""" 
function interpret_location_component(spec, 
                                      coords::AbstractVector{Float32}, 
                                      cmin::Float32, cmax::Float32) 
    nNodes = length(coords) 
    mask = falses(nNodes) 
      
    if spec == ":" 
        return trues(nNodes) 
    end

    
    val = resolve_coordinate_value(spec, cmin, cmax) 
    
    
    min_dist = Float32(Inf)
    @inbounds for i in 1:nNodes
        dist = abs(coords[i] - val)
        if dist < min_dist
            min_dist = dist
        end
    end
    
    
    
    
    
    
    
    domain_len = max(Float32(1.0), abs(cmax - cmin))
    
    
    tolerance = min_dist + (1.0f-5 * domain_len)

    @inbounds for i in 1:nNodes 
        if abs(coords[i] - val) <= tolerance
            mask[i] = true 
        end 
    end 

    return mask 
end 

function resolve_coordinate_value(spec, cmin::Float32, cmax::Float32)
    if isa(spec, Number)
        if spec >= Float32(0.0) && spec <= Float32(1.0) 
            return Float32(cmin + spec*(cmax - cmin)) 
        else 
            return Float32(spec) 
        end
    elseif isa(spec, String) && endswith(spec, "%")
        frac = parse(Float32, replace(spec, "%"=>"")) / Float32(100.0)
        frac = clamp(frac, Float32(0.0), Float32(1.0)) 
        return Float32(cmin + frac*(cmax - cmin))
    end
    return Float32(cmin) 
end

""" 
    get_bc_indicator(nNodes, nodes, bc_data; T=Float32) 
""" 
function get_bc_indicator(nNodes::Int, 
                          nodes::Matrix{Float32}, 
                          bc_data::Vector{Any};  
                          T::Type{<:AbstractFloat} = Float32) 

    bc_indicator = zeros(T, nNodes, 3) 
      
    for bc in bc_data 
        dofs = bc["DoFs"] 
          
        for dof in dofs 
            if dof < 1 || dof > 3 
                error("Invalid DoF index: $dof (must be 1..3).") 
            end 
        end 

        affected = get_affected_nodes(bc, nodes) 
        for nd in affected 
            for d in dofs 
                bc_indicator[nd, d] = one(T) 
            end 
        end 
    end 

    return bc_indicator 
end 

""" 
    reduce_system(K, F, bc_data, nodes, elements) 
""" 
function reduce_system(K::SparseMatrixCSC{Float32,Int}, 
                       F::Vector{Float32}, 
                       bc_data::Vector{Any},  
                       nodes::Matrix{Float32}, 
                       elements::Matrix{Int}) 

    nNodes = size(nodes, 1) 
    ndof    = 3*nNodes 
    constrained = falses(ndof) 

    for bc in bc_data 
        dofs = bc["DoFs"] 
        affected = get_affected_nodes(bc, nodes) 
          
        for nd in affected 
            for d in dofs 
                gdof = 3*(nd-1) + d 
                constrained[gdof] = true 
                F[gdof] = Float32(0.0)  
            end 
        end 
    end 

    free_indices = findall(!, constrained) 
    K_reduced = K[free_indices, free_indices] 
    F_reduced = F[free_indices] 
      
    return K_reduced, F_reduced, free_indices 
end 

function find_nearest_node(target_coords::Vector{Float32}, nodes::Matrix{Float32})
    nNodes = size(nodes, 1)
    best_idx = -1
    min_dist_sq = Inf32

    @inbounds for i in 1:nNodes
        dx = nodes[i, 1] - target_coords[1]
        dy = nodes[i, 2] - target_coords[2]
        dz = nodes[i, 3] - target_coords[3]
        dist_sq = dx*dx + dy*dy + dz*dz

        if dist_sq < (min_dist_sq - 1e-9)
            min_dist_sq = dist_sq
            best_idx = i
        elseif abs(dist_sq - min_dist_sq) <= 1e-9
            if nodes[i, 1] > nodes[best_idx, 1]
                best_idx = i
            elseif nodes[i, 1] == nodes[best_idx, 1]
                if nodes[i, 2] > nodes[best_idx, 2]
                    best_idx = i
                elseif nodes[i, 2] == nodes[best_idx, 2]
                    if nodes[i, 3] > nodes[best_idx, 3]
                        best_idx = i
                    end
                end
            end
        end
    end
    return best_idx
end

""" 
    apply_external_forces!(F, forces_data, nodes, elements) 

Processes external forces.
""" 
function apply_external_forces!(F::Vector{T}, 
                                 forces_data::Vector{Any},  
                                 nodes::Matrix{Float32}, 
                                 elements::Matrix{Int}) where T<:AbstractFloat 

    x_bounds = extrema(view(nodes, :, 1))
    y_bounds = extrema(view(nodes, :, 2))
    z_bounds = extrema(view(nodes, :, 3))

    println("Processing $(length(forces_data)) external forces...")

    for force in forces_data 
        
        force_name = get(force, "name", "Unnamed Force")
        
        affected_nodes = get_affected_nodes(force, nodes) 

        
        if isempty(affected_nodes) && haskey(force, "location")
            loc = force["location"]
            is_point_spec = all(x -> x != ":", loc)
            
            if is_point_spec
                tx = resolve_coordinate_value(loc[1], x_bounds[1], x_bounds[2])
                ty = resolve_coordinate_value(loc[2], y_bounds[1], y_bounds[2])
                tz = resolve_coordinate_value(loc[3], z_bounds[1], z_bounds[2])
                target = Float32[tx, ty, tz]

                nearest_idx = find_nearest_node(target, nodes)
                if nearest_idx != -1
                    affected_nodes = [nearest_idx]
                    println("   -> Force '$force_name': mapped to nearest node #$nearest_idx")
                end
            end
        else
            println("   -> Force '$force_name': mapped to $(length(affected_nodes)) nodes")
        end
        
        if isempty(affected_nodes) 
            continue 
        end 
          
        f_raw = force["F"] 
        f_arr = zeros(T, 3) 
        len_to_copy = min(length(f_raw), 3) 
        f_arr[1:len_to_copy] = T.(f_raw[1:len_to_copy])  

        # If user gave "location", we spread the total force among the matched nodes 
        scale_factor = haskey(force, "location") ? (one(T) / length(affected_nodes)) : one(T) 

        for nd in affected_nodes 
            for i in 1:3 
                global_dof = 3*(nd-1) + i 
                F[global_dof] += scale_factor * f_arr[i] 
            end 
        end 
    end 

    return F 
end 

"""
    add_self_weight!(F, density, mass_density_field, protected_mask, gravity_scale, elements, dx, dy, dz, g_accel)

Calculates gravitational body force.
DECOUPLED LOGIC:
- If element is protected (Shape): Mass = Volume * mass_density_field[e]
- If element is design (Topology): Mass = Volume * density[e] * mass_density_field[e]
"""
function add_self_weight!(F::Vector{T}, 
                          density::Vector{T}, 
                          mass_density_field::Vector{T},
                          protected_mask::BitVector,
                          gravity_scale::T,
                          elements::Matrix{Int},
                          dx::T, dy::T, dz::T,
                          g_accel::T) where T<:AbstractFloat

    elem_vol = dx * dy * dz
    
    n_threads_safe = Threads.nthreads() + 16 
    ndof = length(F)
    F_local = [zeros(T, ndof) for _ in 1:n_threads_safe]

    nElem = length(density)

    Threads.@threads for e in 1:nElem
        rho_topo = density[e]
        rho_mat = mass_density_field[e]
        
        
        effective_mass = 0.0f0
        
        if protected_mask[e]
            
            effective_mass = rho_mat
        else
            
            effective_mass = rho_topo * rho_mat
        end

        if effective_mass > 1e-9 
            tid = Threads.threadid()
            if tid > n_threads_safe; tid = 1; end
            
            
            weight_elem = elem_vol * effective_mass * g_accel * gravity_scale
            
            
            fy_node = -1.0f0 * (weight_elem / T(8.0))
            
            conn = view(elements, e, :)
            for i in 1:8
                node_idx = conn[i]
                gdof_y = 3*(node_idx-1) + 2
                @inbounds F_local[tid][gdof_y] += fy_node
            end
        end
    end

    
    for t in 1:n_threads_safe
        F .+= F_local[t]
    end
end

"""
    compute_global_thermal_forces!(F_total, nodes, elements, alpha_field, delta_T, E, nu, density)

Calculates thermal forces. Uses spatially varying alpha_field.
"""
function compute_global_thermal_forces!(F_total::Vector{Float32}, 
                                        nodes::Matrix{Float32}, 
                                        elements::Matrix{Int},
                                        alpha_field::Vector{Float32},
                                        delta_T::Float32, 
                                        E::Float32, 
                                        nu::Float32, 
                                        density::Vector{Float32})

    if abs(delta_T) < 1e-6
        return
    end

    nElem = size(elements, 1)
    ndof = length(F_total)
    
    
    n_threads_safe = Threads.nthreads() + 16 
    F_local = [zeros(Float32, ndof) for _ in 1:n_threads_safe]

    Threads.@threads for e in 1:nElem
        
        
        if density[e] > 1e-4 && abs(alpha_field[e]) > 1e-9
            tid = Threads.threadid()
            if tid > n_threads_safe; tid = 1; end
            
            conn = view(elements, e, :)
            el_nodes = nodes[conn, :]
            
            # Thermal Force f = B' D e_th * vol
            
            
            
            f_elem = Element.compute_element_thermal_force(el_nodes, E * density[e], nu, alpha_field[e], delta_T)
            
            
            for i in 1:8
                node_idx = conn[i]
                base_dof = 3 * (node_idx - 1)
                @inbounds F_local[tid][base_dof + 1] += f_elem[3*(i-1) + 1]
                @inbounds F_local[tid][base_dof + 2] += f_elem[3*(i-1) + 2]
                @inbounds F_local[tid][base_dof + 3] += f_elem[3*(i-1) + 3]
            end
        end
    end

    
    for t in 1:n_threads_safe
        F_total .+= F_local[t]
    end
end

end
"// # FILE: .\src\Core\Element.jl";
// 

module Element

using LinearAlgebra
export NAT_COORDS, shape_functions, material_matrix, hex_element_stiffness, get_canonical_stiffness, get_scalar_canonical_matrices, compute_element_thermal_force

const NAT_COORDS = Float32[
    -1 -1 -1;
     1 -1 -1;
     1  1 -1;
    -1  1 -1;
    -1 -1  1;
     1 -1  1;
     1  1  1;
    -1  1  1
]

"""
    shape_functions(xi, eta, zeta)
Computes the trilinear shape functions and their derivatives.
"""
function shape_functions(xi, eta, zeta)
    N  = zeros(Float32, 8)
    dN = zeros(Float32, 8, 3)
      
    p1 = Float32(0.125)
      
    @inbounds for i in 1:8
        xi_i, eta_i, zeta_i = NAT_COORDS[i,1], NAT_COORDS[i,2], NAT_COORDS[i,3]
        
        term_xi   = (1.0f0 + xi*xi_i)
        term_eta  = (1.0f0 + eta*eta_i)
        term_zeta = (1.0f0 + zeta*zeta_i)
        
        N[i] = p1 * term_xi * term_eta * term_zeta
        
        dN[i,1] = p1 * xi_i * term_eta * term_zeta
        dN[i,2] = p1 * term_xi * eta_i * term_zeta
        dN[i,3] = p1 * term_xi * term_eta * zeta_i
    end
    return N, dN
end

function material_matrix(E::Float32, nu::Float32)
    inv_den = 1.0f0 / ((1.0f0 + nu) * (1.0f0 - 2.0f0 * nu))
    factor = E * inv_den
      
    c1 = (1.0f0 - nu) * factor
    c2 = nu * factor
    
    
    c3_isotropic = ((1.0f0 - 2.0f0 * nu) / 2.0f0) * factor
    
    
    shear_reduction = 1.0f0 
    
    c3 = c3_isotropic * shear_reduction
      
    D = zeros(Float32, 6, 6)
    D[1,1] = c1; D[1,2] = c2; D[1,3] = c2
    D[2,1] = c2; D[2,2] = c1; D[2,3] = c2
    D[3,1] = c2; D[3,2] = c2; D[3,3] = c1
      
    D[4,4] = c3
    D[5,5] = c3
    D[6,6] = c3
    return D
end

function hex_element_stiffness(nodes::AbstractMatrix{Float32}, E::Float32, nu::Float32)
    D = material_matrix(E, nu)
    ke = zeros(Float32, 24, 24)
    a = 1.0f0 / sqrt(3.0f0)
    gauss_pts = Float32[-a, a]
    B = zeros(Float32, 6, 24)

    @inbounds for xi in gauss_pts, eta in gauss_pts, zeta in gauss_pts
        _, dN_dxi = shape_functions(xi, eta, zeta)
        J    = transpose(dN_dxi) * nodes
        detJ = det(J)
        if detJ <= 0.0f0 
            # error("Non-positive Jacobian detected.") 
        end
        invJ = inv(J)
        
        
        
        
        dN_dx = dN_dxi * invJ

        fill!(B, 0.0f0)
        for i in 1:8
            idx = 3*(i-1)
            dN_i = view(dN_dx, i, :)
            B[1, idx+1] = dN_i[1]; B[2, idx+2] = dN_i[2]; B[3, idx+3] = dN_i[3]
            B[4, idx+1] = dN_i[2]; B[4, idx+2] = dN_i[1]
            B[5, idx+2] = dN_i[3]; B[5, idx+3] = dN_i[2]
            B[6, idx+1] = dN_i[3]; B[6, idx+3] = dN_i[1]
        end
        
        ke .+= transpose(B) * D * B * detJ
    end
    return ke
end

function get_canonical_stiffness(dx::Float32, dy::Float32, dz::Float32, nu::Float32)
    nodes = Float32[
        0.0 0.0 0.0; dx  0.0 0.0; dx  dy  0.0; 0.0 dy  0.0;
        0.0 0.0 dz;  dx  0.0 dz;  dx  dy  dz;  0.0 dy  dz
    ]
    nodes .-= [dx/2 dy/2 dz/2]
    return hex_element_stiffness(nodes, 1.0f0, nu)
end

function get_scalar_canonical_matrices(dx::Float32, dy::Float32, dz::Float32)
    nodes = Float32[
        -dx/2 -dy/2 -dz/2; dx/2 -dy/2 -dz/2; dx/2  dy/2 -dz/2; -dx/2  dy/2 -dz/2;
        -dx/2 -dy/2  dz; dx/2 -dy/2  dz; dx/2  dy/2  dz; -dx/2  dy/2  dz
    ]
    Ke = zeros(Float32, 8, 8)
    Me = zeros(Float32, 8, 8)
    a = 1.0f0 / sqrt(3.0f0)
    gauss_pts = Float32[-a, a]

    @inbounds for xi in gauss_pts, eta in gauss_pts, zeta in gauss_pts
        N, dN_dxi = shape_functions(xi, eta, zeta)
        J = transpose(dN_dxi) * nodes
        detJ = det(J)
        invJ = inv(J)
        
        
        dN_dx = dN_dxi * invJ
        
        weight = detJ 
        Ke .+= (dN_dx * transpose(dN_dx)) .* weight
        Me .+= (N * transpose(N)) .* weight
    end
    return Ke, Me
end

function compute_element_thermal_force(nodes::AbstractMatrix{Float32}, E::Float32, nu::Float32, alpha::Float32, delta_T::Float32)
    f_th = zeros(Float32, 24)
    
    if abs(alpha) < 1e-9 || abs(delta_T) < 1e-9
        return f_th
    end

    D = material_matrix(E, nu)
    
    thermal_strain = zeros(Float32, 6)
    epsilon_mag = alpha * delta_T
    thermal_strain[1] = epsilon_mag
    thermal_strain[2] = epsilon_mag
    thermal_strain[3] = epsilon_mag
    
    sigma_th = D * thermal_strain

    a = 1.0f0 / sqrt(3.0f0)
    gauss_pts = Float32[-a, a]
    B = zeros(Float32, 6, 24)

    @inbounds for xi in gauss_pts, eta in gauss_pts, zeta in gauss_pts
        _, dN_dxi = shape_functions(xi, eta, zeta)
        J    = transpose(dN_dxi) * nodes
        detJ = det(J)
        invJ = inv(J)
        
        
        dN_dx = dN_dxi * invJ

        fill!(B, 0.0f0)
        for i in 1:8
            idx = 3*(i-1)
            dN_i = view(dN_dx, i, :)
            B[1, idx+1] = dN_i[1]; B[2, idx+2] = dN_i[2]; B[3, idx+3] = dN_i[3]
            B[4, idx+1] = dN_i[2]; B[4, idx+2] = dN_i[1]
            B[5, idx+2] = dN_i[3]; B[5, idx+3] = dN_i[2]
            B[6, idx+1] = dN_i[3]; B[6, idx+3] = dN_i[1]
        end
        
        f_th .+= transpose(B) * sigma_th * detJ
    end
    
    return f_th
end

end
"// # FILE: .\src\Core\Stress.jl";

module Stress 

using LinearAlgebra 
using Base.Threads
using CUDA
using Printf
using ..Element 

export compute_stress_field 

const GAUSS_VAL = 0.577350269f0 

"""
    estimate_stress_vram_required(nNodes, nElem, use_voigt)

Estimates total VRAM needed for stress calculation in bytes.
"""
function estimate_stress_vram_required(nNodes::Int, nElem::Int, use_voigt::Bool)
    bytes_per_float32 = 4
    
    
    nodes_mem = nNodes * 3 * bytes_per_float32
    elements_mem = nElem * 8 * 4  
    U_mem = nNodes * 3 * bytes_per_float32
    density_mem = nElem * bytes_per_float32
    
    
    principal_mem = nElem * 3 * bytes_per_float32
    vonmises_mem = nElem * bytes_per_float32
    l1_mem = nElem * bytes_per_float32
    dir_max_mem = nElem * 3 * bytes_per_float32
    dir_min_mem = nElem * 3 * bytes_per_float32
    voigt_mem = use_voigt ? (nElem * 6 * bytes_per_float32) : 0
    
    
    workspace_mem = nNodes * 3 * bytes_per_float32
    
    total = nodes_mem + elements_mem + U_mem + density_mem +
            principal_mem + vonmises_mem + l1_mem + 
            dir_max_mem + dir_min_mem + voigt_mem + workspace_mem
    
    return total
end

"""
    compute_element_stress(element_nodes, element_disp, E, nu)

CPU implementation - computes stress tensor for a single element.
"""
function compute_element_stress(element_nodes::Array{Float32,2}, 
                                element_disp::Array{Float32,1}, 
                                E::Float32, nu::Float32) 
    D = Element.material_matrix(E, nu) 
    
    xi, eta, zeta = 0.0f0, 0.0f0, 0.0f0 
    inv8 = 0.125f0 
    
    j11 = (-element_nodes[1,1] + element_nodes[2,1] + element_nodes[3,1] - element_nodes[4,1] - element_nodes[5,1] + element_nodes[6,1] + element_nodes[7,1] - element_nodes[8,1]) * inv8
    j12 = (-element_nodes[1,2] + element_nodes[2,2] + element_nodes[3,2] - element_nodes[4,2] - element_nodes[5,2] + element_nodes[6,2] + element_nodes[7,2] - element_nodes[8,2]) * inv8
    j13 = (-element_nodes[1,3] + element_nodes[2,3] + element_nodes[3,3] - element_nodes[4,3] - element_nodes[5,3] + element_nodes[6,3] + element_nodes[7,3] - element_nodes[8,3]) * inv8

    j21 = (-element_nodes[1,1] - element_nodes[2,1] + element_nodes[3,1] + element_nodes[4,1] - element_nodes[5,1] - element_nodes[6,1] + element_nodes[7,1] + element_nodes[8,1]) * inv8
    j22 = (-element_nodes[1,2] - element_nodes[2,2] + element_nodes[3,2] + element_nodes[4,2] - element_nodes[5,2] - element_nodes[6,2] + element_nodes[7,2] + element_nodes[8,2]) * inv8
    j23 = (-element_nodes[1,3] - element_nodes[2,3] + element_nodes[3,3] + element_nodes[4,3] - element_nodes[5,3] - element_nodes[6,3] + element_nodes[7,3] + element_nodes[8,3]) * inv8
    
    j31 = (-element_nodes[1,1] - element_nodes[2,1] - element_nodes[3,1] - element_nodes[4,1] + element_nodes[5,1] + element_nodes[6,1] + element_nodes[7,1] + element_nodes[8,1]) * inv8
    j32 = (-element_nodes[1,2] - element_nodes[2,2] - element_nodes[3,2] - element_nodes[4,2] + element_nodes[5,2] + element_nodes[6,2] + element_nodes[7,2] + element_nodes[8,2]) * inv8
    j33 = (-element_nodes[1,3] - element_nodes[2,3] - element_nodes[3,3] - element_nodes[4,3] + element_nodes[5,3] + element_nodes[6,3] + element_nodes[7,3] + element_nodes[8,3]) * inv8

    detJ = j11*(j22*j33 - j23*j32) - j12*(j21*j33 - j23*j31) + j13*(j21*j32 - j22*j31)
    if detJ <= 1.0e-9; detJ = 1.0f0; end
    invDet = 1.0f0 / detJ

    Jinv11 =  (j22*j33 - j23*j32) * invDet
    Jinv12 = -(j12*j33 - j13*j32) * invDet
    Jinv13 =  (j12*j23 - j13*j22) * invDet
    
    Jinv21 = -(j21*j33 - j23*j31) * invDet
    Jinv22 =  (j11*j33 - j13*j31) * invDet
    Jinv23 = -(j11*j23 - j13*j21) * invDet
    
    Jinv31 =  (j21*j32 - j22*j31) * invDet
    Jinv32 = -(j11*j32 - j12*j31) * invDet
    Jinv33 =  (j11*j22 - j12*j21) * invDet

    B = zeros(Float32, 6, 24)
    
    dNi_dxi  = Float32[-0.125,  0.125,  0.125, -0.125, -0.125,  0.125,  0.125, -0.125]
    dNi_deta = Float32[-0.125, -0.125,  0.125,  0.125, -0.125, -0.125,  0.125,  0.125]
    dNi_dzet = Float32[-0.125, -0.125, -0.125, -0.125,  0.125,  0.125,  0.125,  0.125]
    
    for i in 1:8
        
        dN_dx = dNi_dxi[i]*Jinv11 + dNi_deta[i]*Jinv12 + dNi_dzet[i]*Jinv13
        dN_dy = dNi_dxi[i]*Jinv21 + dNi_deta[i]*Jinv22 + dNi_dzet[i]*Jinv23
        dN_dz = dNi_dxi[i]*Jinv31 + dNi_deta[i]*Jinv32 + dNi_dzet[i]*Jinv33
        
        idx = 3*(i-1) + 1
        B[1, idx]   = dN_dx; B[2, idx+1] = dN_dy; B[3, idx+2] = dN_dz
        B[4, idx]   = dN_dy; B[4, idx+1] = dN_dx
        B[5, idx+1] = dN_dz; B[5, idx+2] = dN_dy
        B[6, idx]   = dN_dz; B[6, idx+2] = dN_dx
    end

    strain = B * element_disp 
    stress_voigt = D * strain 

     = zeros(Float32, 3, 3) 
    [1,1] = stress_voigt[1]; [2,2] = stress_voigt[2]; [3,3] = stress_voigt[3]        
    [1,2] = stress_voigt[4]; [2,1] = stress_voigt[4]        
    [2,3] = stress_voigt[5]; [3,2] = stress_voigt[5]        
    [1,3] = stress_voigt[6]; [3,1] = stress_voigt[6]        
    return  
end 

"""
    compute_principal_data()

CPU implementation - eigenvalue decomposition of stress tensor.
"""
function compute_principal_data(::Matrix{Float32}) 
    F = eigen()
    perm = sortperm(F.values, rev=true)
    principal_stresses = F.values[perm]
    principal_vectors  = F.vectors[:, perm]
    max_dir = principal_vectors[:, 1]
    min_dir = principal_vectors[:, 3] 

    xx, yy, zz = [1,1], [2,2], [3,3]
    xy, yz, xz = [1,2], [2,3], [1,3]
    vm = sqrt(0.5f0 * ((xx-yy)^2 + (yy-zz)^2 + (zz-xx)^2) + 3.0f0*(xy^2 + yz^2 + xz^2))  

    return principal_stresses, vm, max_dir, min_dir
end 


@inline function eigen3x3_device(s11, s22, s33, s12, s23, s13)
    v11, v12, v13 = 1.0f0, 0.0f0, 0.0f0
    v21, v22, v23 = 0.0f0, 1.0f0, 0.0f0
    v31, v32, v33 = 0.0f0, 0.0f0, 1.0f0
    
    @fastmath for iter in 1:12
        a12 = abs(s12); a23 = abs(s23); a13 = abs(s13)
        if max(a12, a23, a13) < 1.0e-9; break; 
        end
        
        h = s12; g = 100.0f0 * abs(h)
        if abs(s11) + g != abs(s11) || abs(s22) + g != abs(s22)
            theta = 0.5f0 * (s22 - s11) / h
            t = 1.0f0 / (abs(theta) + sqrt(theta^2 + 1.0f0))
            if theta < 0.0f0; t = -t; end
            c = 1.0f0 / sqrt(t^2 + 1.0f0); s = t * c; tau = s / (1.0f0 + c)
            s11 -= t * s12; s22 += t * s12; s12 = 0.0f0
            tmp = s13; s13 -= s * (s23 + tau * s13); s23 += s * (tmp - tau * s23)
            tmp = v11; v11 -= s * (v12 + tau * v11); v12 += s * (tmp - tau * v12)
            tmp = v21; v21 -= s * (v22 + tau * v21); v22 += s * (tmp - tau * v22)
            tmp = v31; v31 -= s * (v32 + tau * v31); v32 += s * (tmp - tau * v32)
        end

        h = s13; g = 100.0f0 * abs(h)
        if abs(s11) + g != abs(s11) || abs(s33) + g != abs(s33)
            theta = 0.5f0 * (s33 - s11) / h
            t = 1.0f0 / (abs(theta) + sqrt(theta^2 + 1.0f0))
            if theta < 0.0f0; t = -t; end
            c = 1.0f0 / sqrt(t^2 + 1.0f0); s = t * c; tau = s / (1.0f0 + c)
            s11 -= t * s13; s33 += t * s13; s13 = 0.0f0
            tmp = s12; s12 -= s * (s23 + tau * s12); s23 += s * (tmp - tau * s23)
            tmp = v11; v11 -= s * (v13 + tau * v11); v13 += s * (tmp - tau * v13)
            tmp = v21; v21 -= s * (v23 + tau * v21); v23 += s * (tmp - tau * v23)
            tmp = v31; v31 -= s * (v33 + tau * v31); v33 += s * (tmp - tau * v33)
        end

        h = s23; g = 100.0f0 * abs(h)
        if abs(s22) + g != abs(s22) || abs(s33) + g != abs(s33)
            theta = 0.5f0 * (s33 - s22) / h
            t = 1.0f0 / (abs(theta) + sqrt(theta^2 + 1.0f0))
            if theta < 0.0f0; t = -t; end
            c = 1.0f0 / sqrt(t^2 + 1.0f0); s = t * c; tau = s / (1.0f0 + c)
            s22 -= t * s23; s33 += t * s23; s23 = 0.0f0
            tmp = s12; s12 -= s * (s13 + tau * s12); s13 += s * (tmp - tau * s13)
            tmp = v12; v12 -= s * (v13 + tau * v12); v13 += s * (tmp - tau * v13)
            tmp = v22; v22 -= s * (v23 + tau * v22); v23 += s * (tmp - tau * v23)
            tmp = v32; v32 -= s * (v33 + tau * v32); v33 += s * (tmp - tau * v33)
        end
    end
    
    if s11 < s22; t=s11; s11=s22; s22=t; t=v11; v11=v12; v12=t; t=v21; v21=v22; v22=t; t=v31; v31=v32; v32=t; end
    if s22 < s33; t=s22; s22=s33; s33=t; t=v12; v12=v13; v13=t; t=v22; v22=v23; v23=t; t=v32; v32=v33; v33=t; end
    if s11 < s22; t=s11; s11=s22; s22=t; t=v11; v11=v12; v12=t; t=v21; v21=v22; v22=t; t=v31; v31=v32; v32=t; end
    
    return s11, s22, s33, v11, v21, v31, v13, v23, v33
end

function stress_kernel!(principal_field, vonmises_field, voigt_field, l1_norm_field, dir_max_field, dir_min_field,
                        nodes, elements, U, density, E, nu, nElem, save_voigt)
    e = (blockIdx().x - 1) * blockDim().x + threadIdx().x
    if e > nElem; return; end

    dens = density[e]
    
    @fastmath if dens < 1.0e-6
        @inbounds begin
            principal_field[1, e] = 0.0f0
            principal_field[2, e] = 0.0f0
            principal_field[3, e] = 0.0f0
            vonmises_field[e] = 0.0f0
            l1_norm_field[e] = 0.0f0
            dir_max_field[1, e] = 0.0f0; dir_max_field[2, e] = 0.0f0; dir_max_field[3, e] = 0.0f0
            dir_min_field[1, e] = 0.0f0; dir_min_field[2, e] = 0.0f0; dir_min_field[3, e] = 0.0f0
            if save_voigt
                voigt_field[1,e]=0; voigt_field[2,e]=0; voigt_field[3,e]=0
                voigt_field[4,e]=0; voigt_field[5,e]=0; voigt_field[6,e]=0
            end
        end
        return
    end
    
    E_loc = @fastmath E * dens
    
    j11, j12, j13 = 0.0f0, 0.0f0, 0.0f0
    j21, j22, j23 = 0.0f0, 0.0f0, 0.0f0
    j31, j32, j33 = 0.0f0, 0.0f0, 0.0f0
    
    @inbounds for i in 1:8
        nid = elements[e, i]
        nx = nodes[nid, 1]; ny = nodes[nid, 2]; nz = nodes[nid, 3]
        
        xi_val = (i==2 || i==3 || i==6 || i==7) ? 0.125f0 : -0.125f0
        eta_val = (i==3 || i==4 || i==7 || i==8) ? 0.125f0 : -0.125f0
        zet_val = (i>=5) ? 0.125f0 : -0.125f0
        
        j11 += xi_val * nx; j12 += xi_val * ny; j13 += xi_val * nz
        j21 += eta_val * nx; j22 += eta_val * ny; j23 += eta_val * nz
        j31 += zet_val * nx; j32 += zet_val * ny; j33 += zet_val * nz
    end
    
    @fastmath begin
        detJ = j11*(j22*j33 - j23*j32) - j12*(j21*j33 - j23*j31) + j13*(j21*j32 - j22*j31)
        if detJ <= 1.0e-12; detJ = 1.0f0; end
        invDet = 1.0f0 / detJ
        
        Jinv11 =  (j22*j33 - j23*j32) * invDet; Jinv12 = -(j12*j33 - j13*j32) * invDet; Jinv13 =  (j12*j23 - j13*j22) * invDet
        Jinv21 = -(j21*j33 - j23*j31) * invDet; Jinv22 =  (j11*j33 - j13*j31) * invDet; Jinv23 = -(j11*j23 - j13*j21) * invDet
        Jinv31 =  (j21*j32 - j22*j31) * invDet; Jinv32 = -(j11*j32 - j12*j31) * invDet; Jinv33 =  (j11*j22 - j12*j21) * invDet
    end

    eps_xx, eps_yy, eps_zz = 0.0f0, 0.0f0, 0.0f0
    gam_xy, gam_yz, gam_xz = 0.0f0, 0.0f0, 0.0f0
    
    @inbounds for i in 1:8
        nid = elements[e, i]
        base = 3*(nid-1)
        ux = U[base+1]; uy = U[base+2]; uz = U[base+3]
        
        dN_dxi = (i==2 || i==3 || i==6 || i==7) ? 0.125f0 : -0.125f0
        dN_deta = (i==3 || i==4 || i==7 || i==8) ? 0.125f0 : -0.125f0
        dN_dzet = (i>=5) ? 0.125f0 : -0.125f0
        
        
        dN_dx = dN_dxi*Jinv11 + dN_deta*Jinv12 + dN_dzet*Jinv13
        dN_dy = dN_dxi*Jinv21 + dN_deta*Jinv22 + dN_dzet*Jinv23
        dN_dz = dN_dxi*Jinv31 + dN_deta*Jinv32 + dN_dzet*Jinv33
        
        eps_xx += dN_dx * ux
        eps_yy += dN_dy * uy
        eps_zz += dN_dz * uz
        gam_xy += dN_dy * ux + dN_dx * uy
        gam_yz += dN_dz * uy + dN_dy * uz
        gam_xz += dN_dz * ux + dN_dx * uz
    end
    
    @fastmath begin
        fact = E_loc / ((1.0f0 + nu) * (1.0f0 - 2.0f0 * nu))
        c1 = (1.0f0 - nu) * fact
        c2 = nu * fact
        c3 = (0.5f0 - nu) * fact 
        
        sig_xx = c1*eps_xx + c2*eps_yy + c2*eps_zz
        sig_yy = c2*eps_xx + c1*eps_yy + c2*eps_zz
        sig_zz = c2*eps_xx + c2*eps_yy + c1*eps_zz
        sig_xy = c3 * gam_xy 
        sig_yz = c3 * gam_yz
        sig_xz = c3 * gam_xz
    end
    
    if save_voigt
        @inbounds begin
            voigt_field[1, e] = sig_xx
            voigt_field[2, e] = sig_yy
            voigt_field[3, e] = sig_zz
            voigt_field[4, e] = sig_xy
            voigt_field[5, e] = sig_yz
            voigt_field[6, e] = sig_xz
        end
    end
    
    vm_sq = 0.5f0 * ((sig_xx-sig_yy)^2 + (sig_yy-sig_zz)^2 + (sig_zz-sig_xx)^2) + 3.0f0 * (sig_xy^2 + sig_yz^2 + sig_xz^2)
    vm = sqrt(max(0.0f0, vm_sq))
    @inbounds vonmises_field[e] = vm
    
    s11, s22, s33, v1x, v1y, v1z, v3x, v3y, v3z = eigen3x3_device(sig_xx, sig_yy, sig_zz, sig_xy, sig_yz, sig_xz)
    
    
    
    
    
    
    
    val_l1 = abs(s11) + abs(s22) + abs(s33)
    
    if abs(s33) > abs(s11)
        val_l1 = -val_l1
    end
    
    
    @inbounds begin
        principal_field[1, e] = s11
        principal_field[2, e] = s22
        principal_field[3, e] = s33
        
        dir_max_field[1, e] = v1x
        dir_max_field[2, e] = v1y
        dir_max_field[3, e] = v1z

        dir_min_field[1, e] = v3x
        dir_min_field[2, e] = v3y
        dir_min_field[3, e] = v3z
        
        l1_norm_field[e] = val_l1
    end
    return nothing
end

"""
    compute_stress_field_cpu(nodes, elements, U, E, nu, density; return_voigt)

CPU fallback implementation using multi-threading.
"""
function compute_stress_field_cpu(nodes::Matrix{Float32}, elements::Matrix{Int}, 
                                   U::AbstractVector, E::Float32, nu::Float32, 
                                   density::Vector{Float32}; return_voigt::Bool=true)
    
    nElem = size(elements, 1) 
    U_f32 = (eltype(U) == Float32) ? U : Float32.(U)

    principal_field          = zeros(Float32, 3, nElem) 
    vonmises_field           = zeros(Float32, nElem) 
    l1_stress_norm_field     = zeros(Float32, nElem)  
    principal_max_dir_field  = zeros(Float32, 3, nElem)
    principal_min_dir_field  = zeros(Float32, 3, nElem)
    full_stress_voigt = return_voigt ? zeros(Float32, 6, nElem) : zeros(Float32, 0, 0)

    Threads.@threads for e in 1:nElem 
        if density[e] > 1e-6
            conn = elements[e, :] 
            element_nodes = nodes[conn, :] 
            
            element_disp = zeros(Float32, 24) 
            for i in 1:8 
                base_idx = 3*(conn[i]-1)
                element_disp[3*(i-1)+1] = U_f32[base_idx+1]
                element_disp[3*(i-1)+2] = U_f32[base_idx+2]
                element_disp[3*(i-1)+3] = U_f32[base_idx+3]
            end 

            E_local = E * density[e] 
             = compute_element_stress(element_nodes, element_disp, E_local, nu) 
            
            (principal, vm, max_dir, min_dir) = compute_principal_data() 
        
            
            l1_norm = abs(principal[1]) + abs(principal[2]) + abs(principal[3])
            
            
            if abs(principal[3]) > abs(principal[1])
                l1_norm = -l1_norm
            end
            
            
            principal_field[:, e] = principal 
            vonmises_field[e]        = vm 
            l1_stress_norm_field[e] = l1_norm  
            principal_max_dir_field[:, e] = max_dir
            principal_min_dir_field[:, e] = min_dir

            if return_voigt
                full_stress_voigt[:, e] .= ([1,1], [2,2], [3,3], [1,2], [2,3], [1,3]) 
            end
        end
    end 
    
    return principal_field, vonmises_field, full_stress_voigt, l1_stress_norm_field, principal_max_dir_field, principal_min_dir_field
end

"""
    compute_stress_field(nodes, elements, U, E, nu, density; return_voigt)

**HYBRID IMPLEMENTATION**
Automatically selects GPU or CPU based on available VRAM.
"""
function compute_stress_field(nodes::Matrix{Float32}, elements::Matrix{Int}, 
                              U::AbstractVector, E::Float32, nu::Float32, 
                              density::Vector{Float32}; return_voigt::Bool=true) 
    
    nElem = size(elements, 1) 
    nNodes = size(nodes, 1)
    
    
    required_vram = estimate_stress_vram_required(nNodes, nElem, return_voigt)
    
    use_gpu = false
    if CUDA.functional()
        available_vram = CUDA.available_memory()
        vram_threshold = available_vram * 0.75  
        
        req_gb = required_vram / 1024^3
        avail_gb = available_vram / 1024^3
        
        if required_vram < vram_threshold
            use_gpu = true
            println(@sprintf("   [Stress] GPU Mode: %.2f GB required / %.2f GB available", req_gb, avail_gb))
        else
            println(@sprintf("   [Stress] CPU Mode: %.2f GB required > %.2f GB available (%.0f%% threshold)", 
                            req_gb, avail_gb, 75.0))
        end
    else
        println("   [Stress] CPU Mode: CUDA not functional")
    end
    
    
    if use_gpu
        
        U_f32 = (eltype(U) == Float32) ? U : Float32.(U)
        
        principal_field          = zeros(Float32, 3, nElem) 
        vonmises_field           = zeros(Float32, nElem) 
        l1_stress_norm_field     = zeros(Float32, nElem)  
        principal_max_dir_field  = zeros(Float32, 3, nElem)
        principal_min_dir_field  = zeros(Float32, 3, nElem)
        full_stress_voigt = return_voigt ? zeros(Float32, 6, nElem) : zeros(Float32, 0, 0)
        
        
        nodes_gpu    = CuArray(nodes)
        elements_gpu = CuArray(Int32.(elements)) 
        U_gpu        = CuArray(U_f32)
        density_gpu  = CuArray(density)
        
        principal_gpu = CUDA.zeros(Float32, 3, nElem)
        vonmises_gpu  = CUDA.zeros(Float32, nElem)
        l1_gpu        = CUDA.zeros(Float32, nElem)
        dir_max_gpu   = CUDA.zeros(Float32, 3, nElem)
        dir_min_gpu   = CUDA.zeros(Float32, 3, nElem)
        voigt_gpu     = return_voigt ? CUDA.zeros(Float32, 6, nElem) : CUDA.zeros(Float32, 1, 1)
        
        threads = 256
        blocks = cld(nElem, threads)
        
        @cuda threads=threads blocks=blocks stress_kernel!(
            principal_gpu, vonmises_gpu, voigt_gpu, l1_gpu, dir_max_gpu, dir_min_gpu,
            nodes_gpu, elements_gpu, U_gpu, density_gpu, E, nu, nElem, return_voigt
        )
        CUDA.synchronize()
        
        
        copyto!(principal_field, principal_gpu)
        copyto!(vonmises_field, vonmises_gpu)
        copyto!(l1_stress_norm_field, l1_gpu)
        copyto!(principal_max_dir_field, dir_max_gpu)
        copyto!(principal_min_dir_field, dir_min_gpu)
        
        if return_voigt
            copyto!(full_stress_voigt, voigt_gpu)
        end
        
        
        CUDA.unsafe_free!(nodes_gpu); CUDA.unsafe_free!(elements_gpu)
        CUDA.unsafe_free!(U_gpu); CUDA.unsafe_free!(density_gpu)
        CUDA.unsafe_free!(principal_gpu); CUDA.unsafe_free!(vonmises_gpu)
        CUDA.unsafe_free!(voigt_gpu); CUDA.unsafe_free!(l1_gpu)
        CUDA.unsafe_free!(dir_max_gpu); CUDA.unsafe_free!(dir_min_gpu)
        
        GC.gc(); CUDA.reclaim()
        
        return principal_field, vonmises_field, full_stress_voigt, l1_stress_norm_field, principal_max_dir_field, principal_min_dir_field
        
    else
        
        return compute_stress_field_cpu(nodes, elements, U, E, nu, density; return_voigt=return_voigt)
    end
end 
 
end
"// # FILE: .\src\IO\Configuration.jl";


module Configuration 
 
using YAML  
using JSON
using ..Mesh  
using ..Helpers 
using ..MeshShapeProcessing 
 
export load_configuration, load_and_merge_configurations, setup_geometry, initialize_density_field, load_checkpoint
export validate_configuration, print_configuration_summary, export_configuration, compare_configurations
export get_config_value, set_config_value!, apply_preset!
 
""" 
    load_configuration(filename::String) 
 
Load and parse a JSON/YAML configuration file. 
""" 
function load_configuration(filename::String) 
    if !isfile(filename) 
        error("Configuration file '$(filename)' not found") 
    end 
      
    return YAML.load_file(filename) 
end 

function recursive_merge(d1::Dict, d2::Dict)
    result = copy(d1)
    for (k, v) in d2
        if haskey(result, k) && isa(result[k], Dict) && isa(v, Dict)
            result[k] = recursive_merge(result[k], v)
        else
            result[k] = v
        end
    end
    return result
end

function load_and_merge_configurations(domain_file::String, solver_file::String, overrides::Dict)
    println(">>> [CONFIG] Loading Domain: $domain_file")
    domain_config = load_configuration(domain_file)
    
    println(">>> [CONFIG] Loading Solver: $solver_file")
    solver_config = load_configuration(solver_file)
    
    merged = merge(domain_config, solver_config)
    
    if !isempty(overrides)
        println(">>> [CONFIG] Applying $(length(overrides)) override(s)...")
        merged = recursive_merge(merged, overrides)
    end
    
    return merged
end

function load_checkpoint(filename::String)
    println(">>> [Checkpoint] Reading restart data from: $filename")
    
    if !isfile(filename); error("Checkpoint file not found."); end

    data = open(filename, "r") do io
        
        magic = read(io, UInt32) # 0x48455841 "HEXA"
        version = read(io, UInt32)
        
        if magic != 0x48455841
            error("Invalid file format. Not a HEXA checkpoint.")
        end

        iter = Int(read(io, Int32))
        radius = Float32(read(io, Float32))
        threshold = Float32(read(io, Float32))
        
        count = Int(read(io, UInt32)) 
        dx = read(io, Float32)
        dy = read(io, Float32)
        dz = read(io, Float32)

        
        vis_bytes = count * 5 * 4
        seek(io, position(io) + vis_bytes)

        if version >= 3
            u_len = Int(read(io, UInt32))
            seek(io, position(io) + u_len * 4) 
        end

        json_len = Int(read(io, UInt32))
        json_bytes = Vector{UInt8}(undef, json_len)
        read!(io, json_bytes)
        
        config_str = String(json_bytes)
        config = JSON.parse(config_str)

        integral_error = 0.0f0
        if haskey(config, "restart_data")
            integral_error = Float32(get(config["restart_data"], "integral_error", 0.0))
        end

        println("    Restarting at Iteration: $iter")
        println("    Integral Error: $integral_error")

        
        return (config, Float32[], Float32[], integral_error, iter, radius, threshold)
    end

    return data
end
 
""" 
    setup_geometry(config) 
 
Process the geometry configuration and return parameters for mesh generation. 
""" 
function setup_geometry(config) 
      
    length_x = config["geometry"]["length_x"] 
    length_y = config["geometry"]["length_y"] 
    length_z = config["geometry"]["length_z"] 
     
    mesh_conf = get(config, "mesh_settings", Dict())
    raw_count = get(mesh_conf, "initial_ground_mesh_size", 500_000)
    
    target_elem_count = if isa(raw_count, String)
        parse(Int, replace(raw_count, "_" => ""))
    else
        Int(raw_count)
    end
      
    println("Domain dimensions:") 
    println("  X: 0 to $(length_x)") 
    println("  Y: 0 to $(length_y)") 
    println("  Z: 0 to $(length_z)") 
      
    shapes = Any[] 
     
    for (key, shape) in config["geometry"] 
        if key in ["length_x", "length_y", "length_z", 
                   "nElem_x_computed", "nElem_y_computed", "nElem_z_computed", 
                   "dx_computed", "dy_computed", "dz_computed", "max_domain_dim"] 
            continue 
        end 
          
        if haskey(shape, "type") 
            push!(shapes, shape)
        end 
    end 
 
    println("Found $(length(shapes)) geometric modification shapes.") 
      
    nElem_x, nElem_y, nElem_z, dx, dy, dz, actual_elem_count = 
        Helpers.calculate_element_distribution(length_x, length_y, length_z, target_elem_count) 
      
    println("Mesh parameters:") 
    println("  Domain: $(length_x) x $(length_y) x $(length_z) meters") 
    println("  Elements: $(nElem_x) x $(nElem_y) x $(nElem_z) = $(actual_elem_count)") 
    println("  Element sizes: $(dx) x $(dy) x $(dz)") 
      
    max_domain_dim = max(length_x, length_y, length_z) 
 
    return ( 
        nElem_x = nElem_x,  
        nElem_y = nElem_y,  
        nElem_z = nElem_z, 
        dx = dx, 
        dy = dy, 
        dz = dz, 
        shapes = shapes, 
        actual_elem_count = actual_elem_count, 
        max_domain_dim = Float32(max_domain_dim)  
    ) 
end 
 
""" 
    initialize_density_field(nodes, elements, shapes, config)
 
Processes geometric shapes to set the initial density, alpha (thermal), and mass density fields.
""" 
function initialize_density_field(nodes::Matrix{Float32}, 
                                  elements::Matrix{Int}, 
                                  shapes::Vector{Any}, 
                                  config::Dict) 
      
    min_density = Float32(get(config["optimization_parameters"], "min_density", 1e-3)) 
    global_material_density = Float32(get(config["material"], "material_density", 0.0))

    nElem = size(elements, 1) 
    
    println("\n" * "="^80)
    println(">>> [GEOMETRY] Initializing Density Fields")
    println("="^80)
    println("  Total Elements: $(nElem)")
    println("  Number of Shapes: $(length(shapes))")
    println("  Min Density Floor: $(min_density)")
    println("  Base Material Density: $(global_material_density)")
    
    t_init = time()
    density = ones(Float32, nElem) 
    alpha_field = zeros(Float32, nElem)
    mass_density_field = fill(global_material_density, nElem)

    println("  [Timing] Field allocation: $(round((time()-t_init)*1000, digits=2))ms")
    
    t_geom = time()
    MeshShapeProcessing.apply_geometric_modifiers!(density, alpha_field, mass_density_field, nodes, elements, shapes, min_density, global_material_density)
    geom_time = time() - t_geom
    
    println("  [Timing] Geometric processing: $(round(geom_time, digits=2))s")
    println("           Throughput: $(round(nElem/geom_time/1e6, digits=2))M elements/sec")
      
    t_stats = time()
    original_density = copy(density) 
    protected_elements_mask = (original_density .!= 1.0f0) 
    num_protected = sum(protected_elements_mask)
    
    num_voids = count(d -> d < 0.01f0, density)
    num_stiff = count(d -> d > 1.01f0, density)
    num_designable = nElem - num_protected
    
    println("  [Timing] Statistics computation: $(round((time()-t_stats)*1000, digits=2))ms")
    println("\n  Element Classification:")
    println("    Designable:        $(num_designable) ($(round(100*num_designable/nElem, digits=2))%)")
    println("    Protected Total:   $(num_protected) ($(round(100*num_protected/nElem, digits=2))%)")
    println("       Voids:          $(num_voids)")
    println("       Stiff/Solid:    $(num_stiff)")
    
    println("="^80 * "\n")
 
    return density, original_density, protected_elements_mask, alpha_field, mass_density_field
end 

function validate_configuration(config::Dict)
    warnings = String[]
    
    opt_params = get(config, "optimization_parameters", Dict())
    
    max_culling = Float32(get(opt_params, "max_culling_ratio", 0.15))
    if max_culling > 0.3
        push!(warnings, "max_culling_ratio is high ($(max_culling)). Values >0.3 may cause instability.")
    end
    
    final_threshold = Float32(get(opt_params, "final_density_threshold", 0.85))
    if final_threshold > 0.95
        push!(warnings, "final_density_threshold is high ($(final_threshold)). Values >0.95 may trigger collapse.")
    end
    
    solver_params = get(config, "solver_parameters", Dict())
    
    max_iter = Int(get(solver_params, "max_iterations", 40000))
    if max_iter < 1000
        push!(warnings, "max_iterations is low ($max_iter). May not converge for large problems.")
    end
    
    geom = get(config, "geometry", Dict())
    
    lx = get(geom, "length_x", 1.0)
    ly = get(geom, "length_y", 1.0)
    lz = get(geom, "length_z", 1.0)
    
    aspect_ratio = max(lx, ly, lz) / min(lx, ly, lz)
    if aspect_ratio > 10.0
        push!(warnings, "Domain aspect ratio is extreme ($(round(aspect_ratio, digits=1))). May cause solver issues.")
    end
    
    if !isempty(warnings)
        println("\n" * ""^80)
        println(">>> [CONFIG VALIDATION] Warnings:")
        for (i, w) in enumerate(warnings)
            println("  $i. $w")
        end
        println(""^80 * "\n")
    else
        println(">>> [CONFIG VALIDATION] No issues detected.")
    end
    
    return length(warnings) == 0
end

function print_configuration_summary(config::Dict)
    println("\n" * "="^80)
    println(">>> [CONFIGURATION SUMMARY]")
    println("="^80)
    
    hw_profile = get(config, "hardware_profile_applied", get(config, "gpu_profile", "Unknown"))
    println("  Hardware Profile: $hw_profile")
    
    geom = get(config, "geometry", Dict())
    lx = get(geom, "length_x", 0)
    ly = get(geom, "length_y", 0)
    lz = get(geom, "length_z", 0)
    println("  Domain: $(lx)  $(ly)  $(lz)")
    
    n_iter = get(config, "number_of_iterations", 30)
    println("  Iterations: $n_iter")
    
    solver = get(config, "solver_parameters", Dict())
    solver_type = get(solver, "solver_type", "unknown")
    precond = get(solver, "preconditioner", "unknown")
    tol = get(solver, "tolerance", 0.0)
    println("  Solver: $solver_type")
    println("  Preconditioner: $precond")
    println("  Tolerance: $tol")
    
    opt = get(config, "optimization_parameters", Dict())
    max_cull = get(opt, "max_culling_ratio", 0.0)
    final_thresh = get(opt, "final_density_threshold", 0.0)
    println("  Max Culling Ratio: $max_cull")
    println("  Final Density Threshold: $final_thresh")
    
    mesh_conf = get(config, "mesh_settings", Dict())
    target_active = get(mesh_conf, "final_target_of_active_elements", 0)
    max_growth = get(mesh_conf, "max_growth_rate", 0.0)
    println("  Target Active Elements: $target_active")
    println("  Max Growth Rate: $max_growth")
    
    println("="^80 * "\n")
end

function export_configuration(config::Dict, filename::String)
    try
        YAML.write_file(filename, config)
        println(">>> [CONFIG] Exported configuration to: $filename")
        return true
    catch e
        @warn "Failed to export configuration: $e"
        return false
    end
end

function compare_configurations(config1::Dict, config2::Dict)
    println("\n" * "="^80)
    println(">>> [CONFIG COMPARISON]")
    println("="^80)
    
    all_keys = union(keys(config1), keys(config2))
    differences = 0
    
    for key in all_keys
        if !haskey(config1, key)
            println("  ADDED: $key = $(config2[key])")
            differences += 1
        elseif !haskey(config2, key)
            println("  REMOVED: $key = $(config1[key])")
            differences += 1
        elseif config1[key] != config2[key]
            println("  CHANGED: $key")
            println("    From: $(config1[key])")
            println("    To:   $(config2[key])")
            differences += 1
        end
    end
    
    if differences == 0
        println("  No differences found.")
    else
        println("\n  Total differences: $differences")
    end
    
    println("="^80 * "\n")
end

function get_config_value(config::Dict, path::String, default)
    keys_list = split(path, '.')
    current = config
    
    for key in keys_list
        if !haskey(current, key)
            return default
        end
        current = current[key]
    end
    
    return current
end

function set_config_value!(config::Dict, path::String, value)
    keys_list = split(path, '.')
    current = config
    
    for (i, key) in enumerate(keys_list)
        if i == length(keys_list)
            current[key] = value
        else
            if !haskey(current, key) || !isa(current[key], Dict)
                current[key] = Dict()
            end
            current = current[key]
        end
    end
end

function apply_preset!(config::Dict, preset_name::String)
    presets = Dict(
        "conservative" => Dict(
            "optimization_parameters" => Dict(
                "max_culling_ratio" => 0.05,
                "final_density_threshold" => 0.75
            ),
            "solver_parameters" => Dict(
                "tolerance" => 1.0e-7
            )
        ),
        "aggressive" => Dict(
            "optimization_parameters" => Dict(
                "max_culling_ratio" => 0.25,
                "final_density_threshold" => 0.90
            ),
            "solver_parameters" => Dict(
                "tolerance" => 1.0e-5
            )
        ),
        "balanced" => Dict(
            "optimization_parameters" => Dict(
                "max_culling_ratio" => 0.15,
                "final_density_threshold" => 0.85
            ),
            "solver_parameters" => Dict(
                "tolerance" => 1.0e-6
            )
        )
    )
    
    if !haskey(presets, preset_name)
        @warn "Unknown preset: $preset_name. Available: $(keys(presets))"
        return false
    end
    
    preset = presets[preset_name]
    
    for (section, values) in preset
        if !haskey(config, section)
            config[section] = Dict()
        end
        
        for (key, value) in values
            config[section][key] = value
        end
    end
    
    println(">>> [CONFIG] Applied preset: '$preset_name'")
    return true
end

end
"// # FILE: .\src\IO\ExportVTK.jl";

module ExportVTK 

using Printf 
using Base64 

export export_solution_vti, export_solution_legacy, export_solution

"""
    export_solution_vti(...)

Writes the simulation results to a VTK XML Image Data file (.vti).
FIXED: Removed newline before binary marker to prevent byte-alignment errors.
"""
function export_solution_vti(dims::Tuple{Int,Int,Int}, 
                             spacing::Tuple{Float32,Float32,Float32}, 
                             origin::Tuple{Float32,Float32,Float32},
                             density::Vector{Float32}, 
                             l1_stress::Vector{Float32},
                             von_mises::Vector{Float32},
                             nodal_displacement::Matrix{Float32}, 
                             principal_vals::Matrix{Float32},
                             principal_max_dirs::Matrix{Float32},
                             principal_min_dirs::Matrix{Float32},
                             config::Dict, 
                             filename::String)

    nx, ny, nz = dims
    n_cells = length(density)
    n_points = (nx + 1) * (ny + 1) * (nz + 1)
    
    if !endswith(filename, ".vti"); filename *= ".vti"; end

    out_settings = get(config, "output_settings", Dict())
    
    save_stress_vec_val = get(out_settings, "save_principal_stress_vectors", "no")
    write_stress_vectors = (lowercase(string(save_stress_vec_val)) == "yes" || save_stress_vec_val == true)

    save_disp_vec_val = get(out_settings, "save_displacement_vectors", "yes")
    write_disp_vectors = (lowercase(string(save_disp_vec_val)) == "yes" || save_disp_vec_val == true)

    has_displacement = write_disp_vectors && (length(nodal_displacement) == n_points * 3)

    open(filename, "w") do io
        write(io, "<?xml version=\"1.0\"?>\n")
        write(io, "<VTKFile type=\"ImageData\" version=\"0.1\" byte_order=\"LittleEndian\">\n")
        
        extent = "0 $nx 0 $ny 0 $nz"
        dx, dy, dz = spacing
        ox, oy, oz = origin
        
        write(io, "  <ImageData WholeExtent=\"$extent\" Origin=\"$ox $oy $oz\" Spacing=\"$dx $dy $dz\">\n")
        write(io, "    <Piece Extent=\"$extent\">\n")
        
        current_offset = 0
        
        
        write(io, "      <CellData Scalars=\"Density\">\n")
        
        write(io, "        <DataArray type=\"Float32\" Name=\"Density\" format=\"appended\" offset=\"$current_offset\"/>\n")
        current_offset += sizeof(UInt32) + n_cells * sizeof(Float32)
        
        write(io, "        <DataArray type=\"Float32\" Name=\"L1_Stress\" format=\"appended\" offset=\"$current_offset\"/>\n")
        current_offset += sizeof(UInt32) + n_cells * sizeof(Float32)
        
        write(io, "        <DataArray type=\"Float32\" Name=\"VonMises\" format=\"appended\" offset=\"$current_offset\"/>\n")
        current_offset += sizeof(UInt32) + n_cells * sizeof(Float32)

        if write_stress_vectors
            write(io, "        <DataArray type=\"Float32\" Name=\"PrincipalValues\" NumberOfComponents=\"3\" format=\"appended\" offset=\"$current_offset\"/>\n")
            current_offset += sizeof(UInt32) + (n_cells * 3) * sizeof(Float32)

            write(io, "        <DataArray type=\"Float32\" Name=\"MaxPrincipalDirection\" NumberOfComponents=\"3\" format=\"appended\" offset=\"$current_offset\"/>\n")
            current_offset += sizeof(UInt32) + (n_cells * 3) * sizeof(Float32)

            write(io, "        <DataArray type=\"Float32\" Name=\"MinPrincipalDirection\" NumberOfComponents=\"3\" format=\"appended\" offset=\"$current_offset\"/>\n")
            current_offset += sizeof(UInt32) + (n_cells * 3) * sizeof(Float32)
        end
        write(io, "      </CellData>\n")

        
        if has_displacement
            write(io, "      <PointData Vectors=\"Displacement\">\n")
            write(io, "        <DataArray type=\"Float32\" Name=\"Displacement\" NumberOfComponents=\"3\" format=\"appended\" offset=\"$current_offset\"/>\n")
            current_offset += sizeof(UInt32) + (n_points * 3) * sizeof(Float32)
            write(io, "      </PointData>\n")
        end

        write(io, "    </Piece>\n")
        write(io, "  </ImageData>\n")
        
        
        
        
        write(io, "  <AppendedData encoding=\"raw\">") 
        write(io, "_") 
        
        function write_array(arr)
            n_bytes = UInt32(length(arr) * sizeof(Float32))
            write(io, n_bytes)
            write(io, arr)
        end

        write_array(density)
        write_array(l1_stress)
        write_array(von_mises)

        if write_stress_vectors
            write_array(vec(principal_vals)) 
            write_array(vec(principal_max_dirs))
            write_array(vec(principal_min_dirs))
        end

        if has_displacement
            write_array(vec(nodal_displacement))
        end
        
        write(io, "\n  </AppendedData>\n")
        write(io, "</VTKFile>\n")
    end
end

function export_solution_legacy(nodes::Matrix{Float32}, 
                                elements::Matrix{Int}, 
                                U_full::Vector{Float32}, 
                                F::Vector{Float32}, 
                                bc_indicator::Matrix{Float32}, 
                                principal_field::Matrix{Float32}, 
                                vonmises_field::Vector{Float32}, 
                                full_stress_voigt::Matrix{Float32}, 
                                l1_stress_norm_field::Vector{Float32},
                                principal_max_dir_field::Matrix{Float32}; 
                                density::Vector{Float32}=Float32[],
                                filename::String="solution.vtk",
                                kwargs...)
    println("Legacy exporter triggered.")
end

function export_solution(nodes, elements, U, F, bc, p_field, vm, voigt, l1, p_max_dir, p_min_dir; 
                         density=nothing, filename="out.vtk", config=nothing, kwargs...)
                           
    if config !== nothing
        geom = config["geometry"]
        nx = Int(geom["nElem_x_computed"])
        ny = Int(geom["nElem_y_computed"])
        nz = Int(geom["nElem_z_computed"])
        dx = Float32(geom["dx_computed"])
        dy = Float32(geom["dy_computed"])
        dz = Float32(geom["dz_computed"])
        
        out_settings = get(config, "output_settings", Dict())
        save_disp_vec_val = get(out_settings, "save_displacement_vectors", "yes")
        write_disp_vectors = (lowercase(string(save_disp_vec_val)) == "yes" || save_disp_vec_val == true)

        disp_matrix = zeros(Float32, 0, 0)

        if write_disp_vectors
            n_nodes_total = div(length(U), 3)
            disp_matrix = reshape(U, 3, n_nodes_total)
        end

        export_solution_vti((nx, ny, nz), (dx, dy, dz), (0f0, 0f0, 0f0), 
                            density, l1, vm, disp_matrix, p_field, p_max_dir, p_min_dir, config, filename)
    else
        export_solution_legacy(nodes, elements, U, F, bc, p_field, vm, voigt, l1, p_max_dir; 
                               density=density, filename=filename, kwargs...)
    end
end

end
"// # FILE: .\src\IO\Postprocessing.jl";

module Postprocessing

using JSON, Printf
using Base.Threads
using CUDA
using LinearAlgebra
using Logging 
using ..Mesh
using ..MeshUtilities 
using ..ExportVTK
using ..Diagnostics 
import MarchingCubes: MC, march

export export_iteration_results, export_smooth_watertight_stl


include("Postprocessing/MeshTools.jl")
include("Postprocessing/StlExport.jl")
include("Postprocessing/WebExport.jl")
include("Postprocessing/ResultsExport.jl")

end 
"// # FILE: .\src\IO\Postprocessing\MeshTools.jl";


using Base.Threads
using LinearAlgebra
using ..Diagnostics

function safe_parse_int(val, default::Int)
    if val === nothing; return default; end
    if isa(val, Number); return Int(val); end
    if isa(val, String)
        clean_val = replace(val, "_" => "")
        return try parse(Int, clean_val) catch; default end
    end
    return default
end

function get_smooth_nodal_densities(density::Vector{Float32}, elements::Matrix{Int}, nNodes::Int)
    node_sums = zeros(Float32, nNodes)
    node_counts = zeros(Int, nNodes)
    nElem = length(density)
    
    @inbounds for e in 1:nElem
        rho = density[e]
        for i in 1:8
            node_idx = elements[e, i]
            if node_idx > 0 && node_idx <= nNodes
                node_sums[node_idx] += rho
                node_counts[node_idx] += 1
            end
        end
    end
    nodal_density = zeros(Float32, nNodes)
    @inbounds for i in 1:nNodes
        if node_counts[i] > 0
            nodal_density[i] = node_sums[i] / Float32(node_counts[i])
        end
    end
    return nodal_density
end

function smooth_grid!(grid::Array{Float32, 3}, passes::Int)
    if passes <= 0; return; end
    nx, ny, nz = size(grid)
    temp_grid = copy(grid)
    
    for _ in 1:passes
        Threads.@threads for k in 2:(nz-1)
            for j in 2:(ny-1)
                for i in 2:(nx-1)
                    sum_neighbors = grid[i-1,j,k] + grid[i+1,j,k] +
                                    grid[i,j-1,k] + grid[i,j+1,k] +
                                    grid[i,j,k-1] + grid[i,j,k+1]
                    temp_grid[i,j,k] = (grid[i,j,k] * 4.0f0 + sum_neighbors) * 0.1f0
                end
            end
        end
        grid[2:end-1, 2:end-1, 2:end-1] .= temp_grid[2:end-1, 2:end-1, 2:end-1]
    end
end

function trilinear_interpolate(vals, xd::Float32, yd::Float32, zd::Float32)
    c00 = vals[1]*(1f0-xd) + vals[2]*xd
    c01 = vals[4]*(1f0-xd) + vals[3]*xd
    c10 = vals[5]*(1f0-xd) + vals[6]*xd
    c11 = vals[8]*(1f0-xd) + vals[7]*xd
    c0 = c00*(1f0-yd) + c01*yd
    c1 = c10*(1f0-yd) + c11*yd
    return c0*(1f0-zd) + c1*zd
end

function decimate_mesh!(vertices::Vector{Tuple{Float64, Float64, Float64}}, 
                        triangles::AbstractVector, 
                        target_triangle_count::Int)
    current_count = length(triangles)
    
    if current_count > 2_000_000 
        Diagnostics.print_warn("Mesh too large for decimation ($current_count tris). Skipping to preserve performance.")
        return triangles
    end

    if target_triangle_count <= 0 || current_count <= target_triangle_count
        return triangles
    end

    Diagnostics.print_info("Decimating mesh: $current_count -> $target_triangle_count triangles...")
    
    mutable_tris = Vector{Vector{Int}}(undef, current_count)
    for i in 1:current_count
        t = triangles[i]
        mutable_tris[i] = [Int(t[1]), Int(t[2]), Int(t[3])]
    end

    max_passes = 15
    for pass in 1:max_passes
        if length(mutable_tris) <= target_triangle_count; break; end

        edges = Vector{Tuple{Float64, Int, Int}}()
        sizehint!(edges, length(mutable_tris) * 3)

        for t in mutable_tris
            v1, v2, v3 = t[1], t[2], t[3]
            d12 = (vertices[v1][1]-vertices[v2][1])^2 + (vertices[v1][2]-vertices[v2][2])^2 + (vertices[v1][3]-vertices[v2][3])^2
            d23 = (vertices[v2][1]-vertices[v3][1])^2 + (vertices[v2][2]-vertices[v3][2])^2 + (vertices[v2][3]-vertices[v3][3])^2
            d31 = (vertices[v3][1]-vertices[v1][1])^2 + (vertices[v3][2]-vertices[v1][2])^2 + (vertices[v3][3]-vertices[v1][3])^2
            push!(edges, (d12, min(v1,v2), max(v1,v2)))
            push!(edges, (d23, min(v2,v3), max(v2,v3)))
            push!(edges, (d31, min(v3,v1), max(v3,v1)))
        end

        sort!(edges, by = x -> x[1])
        
        replacements = collect(1:length(vertices))
        collapsed_nodes = falses(length(vertices))
        n_collapsed = 0
        
        tris_to_remove = length(mutable_tris) - target_triangle_count
        limit_collapses = max(100, tris_to_remove) 

        for (dist, u, v) in edges
            if n_collapsed >= limit_collapses; break; end
            if !collapsed_nodes[u] && !collapsed_nodes[v]
                replacements[v] = u
                mx = (vertices[u][1] + vertices[v][1]) * 0.5
                my = (vertices[u][2] + vertices[v][2]) * 0.5
                mz = (vertices[u][3] + vertices[v][3]) * 0.5
                vertices[u] = (mx, my, mz)
                collapsed_nodes[u] = true 
                collapsed_nodes[v] = true
                n_collapsed += 1
            end
        end

        if n_collapsed == 0; break; end

        new_triangles = Vector{Vector{Int}}()
        sizehint!(new_triangles, length(mutable_tris))

        for t in mutable_tris
            v1 = replacements[t[1]]
            v2 = replacements[t[2]]
            v3 = replacements[t[3]]
            if v1 != v2 && v1 != v3 && v2 != v3
                push!(new_triangles, [v1, v2, v3])
            end
        end
        mutable_tris = new_triangles
    end
    return mutable_tris
end

function laplacian_smooth_mesh!(vertices::Vector{Tuple{Float64, Float64, Float64}}, 
                                triangles::AbstractVector, 
                                iterations::Int=3, lambda::Float64=0.5)
    if iterations <= 0; return; end
    nv = length(vertices)
    new_pos = Vector{Tuple{Float64, Float64, Float64}}(undef, nv)
    neighbor_counts = zeros(Int, nv)
    neighbor_sums_x = zeros(Float64, nv)
    neighbor_sums_y = zeros(Float64, nv)
    neighbor_sums_z = zeros(Float64, nv)

    for _ in 1:iterations
        fill!(neighbor_counts, 0)
        fill!(neighbor_sums_x, 0.0); fill!(neighbor_sums_y, 0.0); fill!(neighbor_sums_z, 0.0)

        for tri in triangles
            i1, i2, i3 = tri[1], tri[2], tri[3]
            if i1 < 1 || i1 > nv || i2 < 1 || i2 > nv || i3 < 1 || i3 > nv; continue; end
            v1 = vertices[i1]; v2 = vertices[i2]; v3 = vertices[i3]
            neighbor_sums_x[i1] += v2[1]; neighbor_sums_y[i1] += v2[2]; neighbor_sums_z[i1] += v2[3]; neighbor_counts[i1] += 1
            neighbor_sums_x[i1] += v3[1]; neighbor_sums_y[i1] += v3[2]; neighbor_sums_z[i1] += v3[3]; neighbor_counts[i1] += 1
            neighbor_sums_x[i2] += v1[1]; neighbor_sums_y[i2] += v1[2]; neighbor_sums_z[i2] += v1[3]; neighbor_counts[i2] += 1
            neighbor_sums_x[i2] += v3[1]; neighbor_sums_y[i2] += v3[2]; neighbor_sums_z[i2] += v3[3]; neighbor_counts[i2] += 1
            neighbor_sums_x[i3] += v1[1]; neighbor_sums_y[i3] += v1[2]; neighbor_sums_z[i3] += v1[3]; neighbor_counts[i3] += 1
            neighbor_sums_x[i3] += v2[1]; neighbor_sums_y[i3] += v2[2]; neighbor_sums_z[i3] += v2[3]; neighbor_counts[i3] += 1
        end
        
        Threads.@threads for i in 1:nv
            cnt = neighbor_counts[i]
            if cnt > 0
                old_x, old_y, old_z = vertices[i]
                avg_x, avg_y, avg_z = neighbor_sums_x[i]/cnt, neighbor_sums_y[i]/cnt, neighbor_sums_z[i]/cnt
                nx = old_x + lambda * (avg_x - old_x)
                ny = old_y + lambda * (avg_y - old_y)
                nz = old_z + lambda * (avg_z - old_z)
                new_pos[i] = (nx, ny, nz)
            else
                new_pos[i] = vertices[i]
            end
        end
        copyto!(vertices, new_pos)
    end
end
"// # FILE: .\src\IO\Postprocessing\ResultsExport.jl";


using Printf
using ..ExportVTK
using ..Diagnostics

"""
    update_pvd_file(pvd_path, vti_filename, iter)

Updates a .pvd file. Uses purely relative paths for the VTI reference
to ensure the folder can be moved without breaking the animation.
"""
function update_pvd_file(pvd_path::String, vti_full_path::String, iter::Int)
    is_new = !isfile(pvd_path)
    lines = String[]
    
    if !is_new
        try
            lines = readlines(pvd_path)
            filter!(l -> !occursin("</Collection>", l) && !occursin("</VTKFile>", l), lines)
        catch
            is_new = true
        end
    end

    if is_new
        lines = [
            "<?xml version=\"1.0\"?>",
            "<VTKFile type=\"Collection\" version=\"0.1\" byte_order=\"LittleEndian\">",
            "  <Collection>"
        ]
    end

    
    
    base_vti = basename(vti_full_path)
    
    entry = "    <DataSet timestep=\"$iter\" group=\"\" part=\"0\" file=\"$base_vti\"/>"
    push!(lines, entry)
    push!(lines, "  </Collection>")
    push!(lines, "</VTKFile>")

    open(pvd_path, "w") do io
        for line in lines
            println(io, line)
        end
    end
end

function export_iteration_results(iter::Int, base_name::String, RESULTS_DIR::String, 
                                  nodes::Matrix{Float32}, elements::Matrix{Int}, 
                                  U_full::AbstractVector, F::AbstractVector, 
                                  bc_indicator::Matrix{Float32}, principal_field::Matrix{Float32}, 
                                  vonmises_field::Vector{Float32}, full_stress_voigt::Matrix{Float32}, 
                                  l1_stress_norm_field::Vector{Float32}, principal_max_dir_field::Matrix{Float32}, principal_min_dir_field::Matrix{Float32}, 
                                  density::Vector{Float32}, E::Float32, geom; 
                                  iso_threshold::Float32=0.8f0, 
                                  current_radius::Float32=0.0f0, 
                                  integral_error::Float32=0.0f0, 
                                  config::Dict=Dict(), 
                                  save_bin::Bool=true, 
                                  save_stl::Bool=true, 
                                  save_vtk::Bool=true)
      
    U_f32 = (eltype(U_full) == Float32) ? U_full : Float32.(U_full)
    F_f32 = (eltype(F) == Float32) ? F : Float32.(F)

    iter_pad = lpad(iter, 4, '0')
    
    out_settings = get(config, "output_settings", Dict())
    raw_max_cells = get(out_settings, "maximum_cells_in_binary_output", 25_000_000)
    max_export_cells = safe_parse_int(raw_max_cells, 25_000_000)

    raw_stl_target = get(out_settings, "stl_target_triangle_count", 0)
    target_triangles = safe_parse_int(raw_stl_target, 0)

    if save_bin
        try
            print("      > Writing Checkpoint/Web Binary...")
            t_web = time()
            bin_filename = joinpath(RESULTS_DIR, "$(base_name)_webdata.$(iter_pad).bintop")
            export_binary_for_web(
                bin_filename, nodes, elements, density, l1_stress_norm_field, 
                principal_field, geom, iso_threshold, iter, current_radius, 
                integral_error, config; max_export_cells=max_export_cells
            )
            @printf(" done (%.3fs)\n", time() - t_web)
        catch e
            Diagnostics.print_warn("Web binary export failed. Continuing.")
            Diagnostics.write_crash_log("crash_log.txt", "WEB_EXPORT", e, stacktrace(catch_backtrace()), iter, config, density)
        end
    end

    if save_vtk
        try
            print("      > Writing VTK (Paraview)...")
            t_vtk = time()
            
            solution_filename = joinpath(RESULTS_DIR, "$(base_name)_solution.$(iter_pad).vti") 
            
            ExportVTK.export_solution(nodes, elements, U_f32, F_f32, bc_indicator, 
                                      principal_field, vonmises_field, full_stress_voigt, 
                                      l1_stress_norm_field, principal_max_dir_field, principal_min_dir_field; 
                                      density=density, threshold=iso_threshold, scale=Float32(1.0), 
                                      filename=solution_filename,
                                      config=config, 
                                      max_cells=0)

            
            pvd_filename = joinpath(RESULTS_DIR, "$(base_name)_animation.pvd")
            update_pvd_file(pvd_filename, solution_filename, iter)

            @printf(" done (%.3fs)\n", time() - t_vtk)
        catch e
            Diagnostics.print_warn("VTK export failed. Continuing.")
            Diagnostics.write_crash_log("crash_log.txt", "VTK_EXPORT", e, stacktrace(catch_backtrace()), iter, config, density)
        end
    end

    if save_stl && iter > 0 
        print("      > Writing Isosurface STL...")
        t_stl = time()
        stl_filename = joinpath(RESULTS_DIR, "$(base_name)_isosurface.$(iter_pad).stl")
        
        subdiv = get(out_settings, "stl_subdivision_level", 2)
        smooth = get(out_settings, "stl_smoothing_passes", 2)
        mesh_smooth = get(out_settings, "stl_mesh_smoothing_iters", 3)
        
        export_smooth_watertight_stl(density, geom, iso_threshold, stl_filename; 
                                     subdivision_level=subdiv, 
                                     smoothing_passes=smooth,
                                     mesh_smoothing_iters=mesh_smooth,
                                     target_triangle_count=target_triangles)
        @printf(" done (%.3fs)\n", time() - t_stl)
    end
end
"// # FILE: .\src\IO\Postprocessing\StlExport.jl";


using Base.Threads
using ..Diagnostics
using ..Mesh
import MarchingCubes: MC, march

function write_stl_chunked(filename::String, 
                           triangles::AbstractVector, 
                           vertices::Vector{Tuple{Float64, Float64, Float64}})
    
    n_tri = length(triangles)
    
    open(filename, "w") do io
        header_str = "HEXA TopOpt Optimized Binary STL"
        header = zeros(UInt8, 80)
        copyto!(header, 1, codeunits(header_str), 1, min(length(header_str), 80))
        write(io, header)
        write(io, UInt32(n_tri))

        CHUNK_SIZE = 1_000_000 
        buffer = Vector{UInt8}(undef, CHUNK_SIZE * 50)
        
        n_chunks = cld(n_tri, CHUNK_SIZE)
        
        for c in 1:n_chunks
            start_idx = (c - 1) * CHUNK_SIZE + 1
            end_idx = min(c * CHUNK_SIZE, n_tri)
            n_in_chunk = end_idx - start_idx + 1
            
            n_threads = Threads.nthreads()
            batch_size = cld(n_in_chunk, n_threads)
            
            Threads.@threads for t in 1:n_threads
                t_start = start_idx + (t - 1) * batch_size
                t_end = min(start_idx + t * batch_size - 1, end_idx)
                
                if t_start <= t_end
                    for i in t_start:t_end
                        local_i = i - start_idx
                        offset = local_i * 50
                        
                        tri = triangles[i]
                        
                        if tri[1] < 1 || tri[1] > length(vertices) ||
                           tri[2] < 1 || tri[2] > length(vertices) ||
                           tri[3] < 1 || tri[3] > length(vertices)
                            continue
                        end

                        v1 = vertices[tri[1]]
                        v2 = vertices[tri[2]]
                        v3 = vertices[tri[3]]
                        
                        e1x, e1y, e1z = v2[1]-v1[1], v2[2]-v1[2], v2[3]-v1[3]
                        e2x, e2y, e2z = v3[1]-v1[1], v3[2]-v1[2], v3[3]-v1[3]
                        nx, ny, nz = e1y*e2z - e1z*e2y, e1z*e2x - e1x*e2z, e1x*e2y - e1y*e2x
                        mag = sqrt(nx*nx + ny*ny + nz*nz)
                        if mag > 1e-12; nx/=mag; ny/=mag; nz/=mag; else; nx=0.0; ny=0.0; nz=0.0; end
                        
                        ptr = pointer(buffer, offset + 1)
                        p_f32 = reinterpret(Ptr{Float32}, ptr)
                        
                        unsafe_store!(p_f32, Float32(nx), 1)
                        unsafe_store!(p_f32, Float32(ny), 2)
                        unsafe_store!(p_f32, Float32(nz), 3)
                        
                        unsafe_store!(p_f32, Float32(v1[1]), 4)
                        unsafe_store!(p_f32, Float32(v1[2]), 5)
                        unsafe_store!(p_f32, Float32(v1[3]), 6)
                        
                        unsafe_store!(p_f32, Float32(v2[1]), 7)
                        unsafe_store!(p_f32, Float32(v2[2]), 8)
                        unsafe_store!(p_f32, Float32(v2[3]), 9)
                        
                        unsafe_store!(p_f32, Float32(v3[1]), 10)
                        unsafe_store!(p_f32, Float32(v3[2]), 11)
                        unsafe_store!(p_f32, Float32(v3[3]), 12)
                        
                        p_u16 = reinterpret(Ptr{UInt16}, ptr + 48)
                        unsafe_store!(p_u16, UInt16(0), 1)
                    end
                end
            end
            
            bytes_to_write = n_in_chunk * 50
            write(io, view(buffer, 1:bytes_to_write))
        end
    end
end

function export_smooth_watertight_stl(density::Vector{Float32}, geom, threshold::Float32, filename::String; 
                                      subdivision_level::Int=2, smoothing_passes::Int=2, 
                                      mesh_smoothing_iters::Int=3, target_triangle_count::Int=0) 
    
    min_d, max_d = extrema(density)
    if max_d < threshold
        Diagnostics.print_info("Skipping STL: Max density ($max_d) < threshold ($threshold). No surface exists.")
        return
    end

    try
        dir_path = dirname(filename)
        if !isempty(dir_path) && !isdir(dir_path); mkpath(dir_path); end

        NX, NY, NZ = geom.nElem_x, geom.nElem_y, geom.nElem_z
        dx, dy, dz = geom.dx, geom.dy, geom.dz
        
        
        actual_subdivision = max(1, subdivision_level)
        
        if length(density) > 5_000_000
             actual_subdivision = 1
        end

        nodes_coarse, elements_coarse, _ = Mesh.generate_mesh(NX, NY, NZ; dx=dx, dy=dy, dz=dz)
        nNodes_coarse = size(nodes_coarse, 1)
        if length(density) != size(elements_coarse, 1); return; end
        
        nodal_density_coarse = get_smooth_nodal_densities(density, elements_coarse, nNodes_coarse)
        grid_coarse = reshape(nodal_density_coarse, (NX+1, NY+1, NZ+1))
        smooth_grid!(grid_coarse, smoothing_passes)

        sub_NX, sub_NY, sub_NZ = NX * actual_subdivision, NY * actual_subdivision, NZ * actual_subdivision
        pad = 1 
        fine_dim_x, fine_dim_y, fine_dim_z = sub_NX+1+2*pad, sub_NY+1+2*pad, sub_NZ+1+2*pad
        sub_dx, sub_dy, sub_dz = dx/Float32(actual_subdivision), dy/Float32(actual_subdivision), dz/Float32(actual_subdivision)

        fine_grid = zeros(Float32, fine_dim_x, fine_dim_y, fine_dim_z)
        x_coords = collect(Float32, range(-pad*sub_dx, step=sub_dx, length=fine_dim_x))
        y_coords = collect(Float32, range(-pad*sub_dy, step=sub_dy, length=fine_dim_y))
        z_coords = collect(Float32, range(-pad*sub_dz, step=sub_dz, length=fine_dim_z))

        Threads.@threads for k_f in (1+pad):(fine_dim_z-pad)
            for j_f in (1+pad):(fine_dim_y-pad)
                for i_f in (1+pad):(fine_dim_x-pad)
                    ix, iy, iz = i_f-(1+pad), j_f-(1+pad), k_f-(1+pad)
                    idx_x, idx_y, idx_z = div(ix, actual_subdivision), div(iy, actual_subdivision), div(iz, actual_subdivision)
                    if idx_x >= NX; idx_x = NX - 1; end
                    if idx_y >= NY; idx_y = NY - 1; end
                    if idx_z >= NZ; idx_z = NZ - 1; end
                    c_i, c_j, c_k = idx_x + 1, idx_y + 1, idx_z + 1
                    rem_x, rem_y, rem_z = ix - idx_x*actual_subdivision, iy - idx_y*actual_subdivision, iz - idx_z*actual_subdivision
                    xd, yd, zd = Float32(rem_x)/actual_subdivision, Float32(rem_y)/actual_subdivision, Float32(rem_z)/actual_subdivision
                    vals = (grid_coarse[c_i,c_j,c_k], grid_coarse[c_i+1,c_j,c_k], grid_coarse[c_i+1,c_j+1,c_k], grid_coarse[c_i,c_j+1,c_k],
                            grid_coarse[c_i,c_j,c_k+1], grid_coarse[c_i+1,c_j,c_k+1], grid_coarse[c_i+1,c_j+1,c_k+1], grid_coarse[c_i,c_j+1,c_k+1])
                    fine_grid[i_f, j_f, k_f] = trilinear_interpolate(vals, xd, yd, zd)
                end
            end
        end

        mc_struct = MC(fine_grid, Int; normal_sign=1, x=x_coords, y=y_coords, z=z_coords)
        march(mc_struct, threshold)
        
        if length(mc_struct.vertices) == 0
            Diagnostics.print_warn("STL generation produced 0 vertices (Empty).")
            return
        end

        final_triangles = collect(mc_struct.triangles) 
        final_vertices = [(Float64(v[1]), Float64(v[2]), Float64(v[3])) for v in mc_struct.vertices]

        if mesh_smoothing_iters > 0
            try
                verts_tuple = copy(final_vertices)
                laplacian_smooth_mesh!(verts_tuple, final_triangles, mesh_smoothing_iters, 0.5)
                final_vertices = verts_tuple
            catch e
                Diagnostics.print_warn("Mesh smoothing failed: $e")
            end
        end

        if target_triangle_count > 0 && length(final_triangles) > target_triangle_count
             try
                 final_triangles = decimate_mesh!(final_vertices, final_triangles, target_triangle_count)
             catch e
                 Diagnostics.print_error("Mesh decimation failed ($e). Exporting un-decimated mesh.")
             end
        end

        write_stl_chunked(filename, final_triangles, final_vertices)

    catch e
        Diagnostics.print_error("STL Export crashed: $e")
        Diagnostics.write_crash_log("crash_log.txt", "STL_EXPORT", e, stacktrace(catch_backtrace()), 0, Dict(), Float32[])
    end
end
"// # FILE: .\src\IO\Postprocessing\WebExport.jl";
// # FILE: .\src\IO\Postprocessing\WebExport.jl";


using JSON
using Base.Threads
using ..MeshUtilities
using ..Diagnostics

function export_binary_for_web(filename::String, 
                               nodes::Matrix{Float32}, 
                               elements::Matrix{Int}, 
                               density::Vector{Float32}, 
                               l1_stress::Vector{Float32}, 
                               principal_field::Matrix{Float32}, 
                               geom, 
                               threshold::Float32, 
                               iter::Int, 
                               current_radius::Float32, 
                               integral_error::Float32, 
                               config::Dict; 
                               max_export_cells::Int=0) 
    
    all_active_indices = findall(x -> x >= threshold, density)
    n_active = length(all_active_indices)
    if n_active == 0; return; end

    if max_export_cells > 0 && n_active > max_export_cells
        step_val = n_active / max_export_cells
        indices_to_export = Int[]
        sizehint!(indices_to_export, max_export_cells)
        curr_float_idx = 1.0
        while curr_float_idx <= n_active
            idx_int = floor(Int, curr_float_idx)
            if idx_int <= n_active
                push!(indices_to_export, all_active_indices[idx_int])
            end
            curr_float_idx += step_val
        end
        valid_indices = indices_to_export
    else
        valid_indices = all_active_indices
    end

    count = length(valid_indices)

    
    meta = deepcopy(config)
    meta["iteration"] = iter
    meta["radius"] = current_radius
    meta["threshold"] = threshold
    
    
    meta["restart_data"] = Dict(
        "integral_error" => integral_error,
        "n_nodes" => size(nodes, 1),
        "n_elements" => size(elements, 1)
    )

    if !haskey(meta, "mesh_settings"); meta["mesh_settings"] = Dict(); end
    meta["mesh_settings"]["initial_ground_mesh_size"] = size(elements, 1)

    
    # The viewer looks for an "action" field ("add" or "remove") to color shapes.
    if haskey(meta, "geometry") && isa(meta["geometry"], Dict)
        for (key, shape) in meta["geometry"]
            if isa(shape, Dict) && haskey(shape, "type")
                if !haskey(shape, "action")
                    
                    stiffness_val = nothing
                    
                    
                    if haskey(shape, "stiffness_ratio")
                        stiffness_val = Float32(shape["stiffness_ratio"])
                    end
                    
                    # Check new 'properties' sub-dictionary (this overrides root)
                    if haskey(shape, "properties") && isa(shape["properties"], Dict)
                        props = shape["properties"]
                        if haskey(props, "stiffness_ratio")
                            stiffness_val = Float32(props["stiffness_ratio"])
                        end
                    end
                    
                    
                    if stiffness_val !== nothing
                        shape["action"] = stiffness_val > 0.0f0 ? "add" : "remove"
                    else
                        
                        shape["action"] = "add"
                    end
                end
            end
        end
    end

    meta["loads"] = get(config, "external_forces", [])
    meta["bcs"] = get(config, "boundary_conditions", [])
    meta["settings"] = get(config, "optimization_parameters", Dict())
    
    json_str = JSON.json(meta)
    json_bytes = Vector{UInt8}(json_str)
    json_len = UInt32(length(json_bytes))

    try
        open(filename, "w") do io
            write(io, 0x48455841) # Magic "HEXA"
            write(io, UInt32(2))  
            write(io, Int32(iter))
            write(io, Float32(current_radius))
            write(io, Float32(threshold))
            write(io, UInt32(count))
            write(io, Float32(geom.dx))
            write(io, Float32(geom.dy))
            write(io, Float32(geom.dz))

            centroids = zeros(Float32, count * 3)
            densities = zeros(Float32, count)
            signed_l1 = zeros(Float32, count)

            Threads.@threads for i in 1:count
                idx = valid_indices[i]
                c = MeshUtilities.element_centroid(idx, nodes, elements)
                centroids[3*(i-1)+1] = c[1]
                centroids[3*(i-1)+2] = c[2]
                centroids[3*(i-1)+3] = c[3]

                densities[i] = density[idx]

                
                signed_l1[i] = l1_stress[idx]
            end

            write(io, centroids)
            write(io, densities)
            write(io, signed_l1)
            
            write(io, json_len)
            write(io, json_bytes)
        end
    catch e
        Diagnostics.print_error("[Binary Export] Failed to write file: $e")
    end
end
"// # FILE: .\src\Mesh\Mesh.jl";
module Mesh 
 
export node_index, generate_mesh 

 
using LinearAlgebra, Printf 
 
""" 
    node_index(i, j, k, nNodes_x, nNodes_y) 
 
Converts 3D indices (i, j, k) into a linear node index (columnmajor ordering). 
""" 
function node_index(i, j, k, nNodes_x, nNodes_y) 
    return i + (j-1)*nNodes_x + (k-1)*nNodes_x*nNodes_y 
end 
 
""" 
    generate_mesh(nElem_x, nElem_y, nElem_z; 
                  dx=1.0f0, dy=1.0f0, dz=1.0f0) 
 
Generates a structured (prismatic) hexahedral mesh. 
""" 
function generate_mesh(nElem_x::Int, nElem_y::Int, nElem_z::Int; 
                       dx::Float32=Float32(1.0),  
                       dy::Float32=Float32(1.0),  
                       dz::Float32=Float32(1.0))  
      
    nNodes_x = nElem_x + 1 
    nNodes_y = nElem_y + 1 
    nNodes_z = nElem_z + 1 
    dims = (nNodes_x, nNodes_y, nNodes_z) 
        
    nNodes = nNodes_x * nNodes_y * nNodes_z 
    nodes = zeros(Float32, nNodes, 3) 
    idx = 1 
    for k in 1:nNodes_z, j in 1:nNodes_y, i in 1:nNodes_x 
        nodes[idx, :] = [(i-1)*dx, (j-1)*dy, (k-1)*dz] 
        idx += 1 
    end 
      
    nElem = (nNodes_x - 1) * (nNodes_y - 1) * (nNodes_z - 1) 
    elements = Matrix{Int}(undef, nElem, 8) 
    elem_idx = 1 
    for k in 1:(nNodes_z-1), j in 1:(nNodes_y-1), i in 1:(nNodes_x-1) 
        n1 = node_index(i, j, k, nNodes_x, nNodes_y) 
        n2 = node_index(i+1, j, k, nNodes_x, nNodes_y) 
        n3 = node_index(i+1, j+1, k, nNodes_x, nNodes_y) 
        n4 = node_index(i, j+1, k, nNodes_x, nNodes_y) 
        n5 = node_index(i, j, k+1, nNodes_x, nNodes_y) 
        n6 = node_index(i+1, j, k+1, nNodes_x, nNodes_y) 
        n7 = node_index(i+1, j+1, k+1, nNodes_x, nNodes_y) 
        n8 = node_index(i, j+1, k+1, nNodes_x, nNodes_y) 
        elements[elem_idx, :] = [n1, n2, n3, n4, n5, n6, n7, n8] 
        elem_idx += 1 
    end 
 
    println("Generated structured mesh: $(nElem) elements, $(nNodes) nodes.") 
 
    return nodes, elements, dims 
end 
 
end
"// # FILE: .\src\Mesh\MeshPruner.jl";


module MeshPruner

using LinearAlgebra
using SparseArrays

export prune_system, reconstruct_full_solution

function prune_system(nodes::Matrix{Float32}, 
                      elements::Matrix{Int}, 
                      density::Vector{Float32}, 
                      threshold::Float32, 
                      bc_indicator::Matrix{Float32}, 
                      F::Vector{Float32})

    nElem = size(elements, 1)
    nNodes = size(nodes, 1)

    active_mask = density .> threshold
    active_element_indices = findall(active_mask)
    nActiveElem = length(active_element_indices)

    if nActiveElem == 0
        error("MeshPruner: No active elements found (Threshold: $threshold). System is empty.")
    end

    active_nodes_mask = falses(nNodes)
    
    for e in active_element_indices
        for i in 1:8
            node_idx = elements[e, i]
            active_nodes_mask[node_idx] = true
        end
    end

    old_to_new_node_map = zeros(Int, nNodes)
    new_to_old_node_map = Int[]
    
    current_new_id = 1
    for i in 1:nNodes
        if active_nodes_mask[i]
            old_to_new_node_map[i] = current_new_id
            push!(new_to_old_node_map, i)
            current_new_id += 1
        end
    end
    
    nActiveNodes = length(new_to_old_node_map)
    reduced_nodes = nodes[new_to_old_node_map, :]

    reduced_elements = Matrix{Int}(undef, nActiveElem, 8)
    for (i, old_e_idx) in enumerate(active_element_indices)
        for j in 1:8
            old_node = elements[old_e_idx, j]
            new_node = old_to_new_node_map[old_node]
            reduced_elements[i, j] = new_node
        end
    end

    reduced_bc = bc_indicator[new_to_old_node_map, :]
    reduced_ndof = nActiveNodes * 3
    reduced_F = zeros(Float32, reduced_ndof)
    
    for (new_idx, old_idx) in enumerate(new_to_old_node_map)
        base_old = 3 * (old_idx - 1)
        base_new = 3 * (new_idx - 1)
        reduced_F[base_new+1] = F[base_old+1]
        reduced_F[base_new+2] = F[base_old+2]
        reduced_F[base_new+3] = F[base_old+3]
    end

    reduced_density = density[active_element_indices]

    return (
        nodes = reduced_nodes,
        elements = reduced_elements,
        bc_indicator = reduced_bc,
        F = reduced_F,
        density = reduced_density,
        old_to_new_node_map = old_to_new_node_map,
        new_to_old_node_map = new_to_old_node_map,
        active_element_indices = active_element_indices,
        n_original_nodes = nNodes,
        n_original_elems = nElem
    )
end

function reconstruct_full_solution(u_reduced::AbstractVector, 
                                   new_to_old_node_map::Vector{Int}, 
                                   n_full_nodes::Int)
    
    T = eltype(u_reduced)
    ndof_full = n_full_nodes * 3
    u_full = zeros(T, ndof_full)

    for (new_node_idx, old_node_idx) in enumerate(new_to_old_node_map)
        base_new = 3 * (new_node_idx - 1)
        base_old = 3 * (old_node_idx - 1)

        u_full[base_old+1] = u_reduced[base_new+1]
        u_full[base_old+2] = u_reduced[base_new+2]
        u_full[base_old+3] = u_reduced[base_new+3]
    end

    return u_full
end

end
"// # FILE: .\src\Mesh\MeshRefiner.jl";


module MeshRefiner

using LinearAlgebra
using Printf
using Base.Threads
using ..Mesh
using ..Helpers

export refine_mesh_and_fields

function estimate_element_memory_cost_bytes(hard_element_limit::Int)
    if hard_element_limit > 500_000_000 
        return 180 
    else
        return 220 
    end
end

"""
    sample_nearest_neighbor(grid, nx, ny, nz, tx, ty, tz)

Robust Piecewise Constant (Nearest Neighbor) sampling.
"""
@inline function sample_nearest_neighbor(grid::Vector{Float32}, nx::Int, ny::Int, nz::Int, 
                                         tx::Float32, ty::Float32, tz::Float32)
    
    
    ix = clamp(floor(Int, tx * nx), 0, nx - 1)
    iy = clamp(floor(Int, ty * ny), 0, ny - 1)
    iz = clamp(floor(Int, tz * nz), 0, nz - 1)

    
    idx = (ix + 1) + (iy * nx) + (iz * nx * ny)
    
    return @inbounds grid[idx]
end

function refine_mesh_and_fields(nodes::Matrix{Float32}, 
                                elements::Matrix{Int}, 
                                density::Vector{Float32}, 
                                alpha_field::Vector{Float32}, 
                                mass_density_field::Vector{Float32},
                                current_dims::Tuple{Int, Int, Int},
                                target_active_count::Int, 
                                domain_bounds::NamedTuple; 
                                max_growth_rate::Float64=1.2, 
                                hard_element_limit::Int=800_000_000,
                                update_method::String="hard") 

    C_RESET = "\u001b[0m"
    C_BOLD = "\u001b[1m"
    C_CYAN = "\u001b[36m"
    C_GREEN = "\u001b[32m"
    C_YELLOW = "\u001b[33m"

    println("\n" * C_CYAN * "="^60 * C_RESET)
    println(C_CYAN * C_BOLD * ">>> [MESH REFINER] Evaluating Refinement (Conservative Voxel Split)" * C_RESET)

    n_total_old = length(density)
    n_active_old = count(d -> d > 0.001f0, density) 
    active_ratio = max(0.0001, n_active_old / n_total_old) 
     
    println("    Current Total Elements:  $(n_total_old)")
    println("    Current Active Elements: $(n_active_old) ($(round(active_ratio*100, digits=2))%)")
    println("    Target Active Limit:     $(target_active_count)")

    ideal_total_from_target = round(Int, (target_active_count / active_ratio) * 0.90)
    rate_limit_elements = round(Int, n_total_old * max_growth_rate)
    
    final_new_total = n_total_old

    if n_active_old >= target_active_count
        println(C_GREEN * "    [OK] Target active count reached. Maintaining mesh resolution." * C_RESET)
        final_new_total = n_total_old 
    else
        limits = [
            ("Target Active Limit", ideal_total_from_target),
            ("Growth Rate Limit", rate_limit_elements),
            ("Config Hard Limit", hard_element_limit)
        ]
        
        sort!(limits, by = x -> x[2])
        
        limiting_factor_name = limits[1][1]
        final_new_total = limits[1][2]
        
        println("    Constraint Analysis:")
        for (name, val) in limits
            col = (name == limiting_factor_name) ? C_YELLOW : C_RESET
            println("      - $col$name: $(Base.format_bytes(val * 200)) approx ($val elems)$C_RESET")
        end
        println("    LIMIT APPLIED: $C_YELLOW$limiting_factor_name$C_RESET")
    end

    if final_new_total > hard_element_limit
        final_new_total = hard_element_limit
    end

    
    if final_new_total < (n_total_old * 1.05)
        println(C_YELLOW * "    [SKIP] Calculated growth too small (< 5%). Skipping." * C_RESET)
        println(C_CYAN * "="^60 * "\n" * C_RESET)
        return nodes, elements, density, alpha_field, mass_density_field, current_dims
    end

    println(C_GREEN * C_BOLD * "    >>> EXECUTING REFINEMENT TO: $final_new_total elements" * C_RESET)

    len_x, len_y, len_z = domain_bounds.len_x, domain_bounds.len_y, domain_bounds.len_z
    new_nx, new_ny, new_nz, new_dx, new_dy, new_dz, actual_count = 
        Helpers.calculate_element_distribution(len_x, len_y, len_z, final_new_total)
        
    println("      > Grid: $(new_nx)x$(new_ny)x$(new_nz) = $actual_count")
    println("      > Res:  $(new_dx) x $(new_dy) x $(new_dz)")

    new_nodes, new_elements, new_dims = Mesh.generate_mesh(
        new_nx, new_ny, new_nz; 
        dx=new_dx, dy=new_dy, dz=new_dz
    )
    
    
    min_pt = domain_bounds.min_pt
    new_nodes[:, 1] .+= min_pt[1]
    new_nodes[:, 2] .+= min_pt[2]
    new_nodes[:, 3] .+= min_pt[3]
    
    println("      > Mapping fields (Nearest Neighbor / Voxel Split)...")
    n_new_total = size(new_elements, 1)
    
    new_density = zeros(Float32, n_new_total)
    new_alpha   = zeros(Float32, n_new_total) 
    new_mass    = zeros(Float32, n_new_total)
    
    old_nx = Int(current_dims[1] - 1)
    old_ny = Int(current_dims[2] - 1)
    old_nz = Int(current_dims[3] - 1)
    
    
    new_nx_64 = Int64(new_nx)
    new_ny_64 = Int64(new_ny)
    
    Threads.@threads for e_new in 1:n_new_total
        
        e_new_idx = Int64(e_new)
        
        tmp = e_new_idx - 1
        iz = div(tmp, new_nx_64 * new_ny_64)
        rem = tmp % (new_nx_64 * new_ny_64)
        iy = div(rem, new_nx_64)
        ix = rem % new_nx_64
        
        
        
        tx = (Float32(ix) + 0.5f0) / Float32(new_nx)
        ty = (Float32(iy) + 0.5f0) / Float32(new_ny)
        tz = (Float32(iz) + 0.5f0) / Float32(new_nz)
        
        
        
        new_density[e_new] = sample_nearest_neighbor(density, old_nx, old_ny, old_nz, tx, ty, tz)
        new_alpha[e_new]   = sample_nearest_neighbor(alpha_field, old_nx, old_ny, old_nz, tx, ty, tz)
        new_mass[e_new]    = sample_nearest_neighbor(mass_density_field, old_nx, old_ny, old_nz, tx, ty, tz)
    end
    
    println(C_GREEN * "    [DONE] Refinement Complete (Boundary Preserved)." * C_RESET)
    println(C_CYAN * "="^60 * "\n" * C_RESET)

    return new_nodes, new_elements, new_density, new_alpha, new_mass, new_dims
end

end
"// # FILE: .\src\Mesh\MeshShapeProcessing.jl";


module MeshShapeProcessing 
 
export apply_geometric_modifiers!
 
using LinearAlgebra 
using Base.Threads
using ..MeshUtilities       
 
"""
    precompute_shape_bboxes(shapes)

Precompute bounding boxes for each shape to enable early rejection.
"""
function precompute_shape_bboxes(shapes::Vector{Any})
    bboxes = Vector{NamedTuple{(:xmin, :xmax, :ymin, :ymax, :zmin, :zmax), NTuple{6, Float32}}}(undef, length(shapes))
    
    for (i, shape) in enumerate(shapes)
        shape_type = lowercase(get(shape, "type", ""))
        
        if shape_type == "sphere"
            center = tuple(Float32.(shape["center"])...)
            radius = Float32(shape["diameter"]) / 2.0f0
            bboxes[i] = (
                xmin = center[1] - radius, xmax = center[1] + radius,
                ymin = center[2] - radius, ymax = center[2] + radius,
                zmin = center[3] - radius, zmax = center[3] + radius
            )
        elseif shape_type == "box"
            center = tuple(Float32.(shape["center"])...)
            
            if haskey(shape, "size")
                sz_raw = shape["size"]
                if isa(sz_raw, AbstractVector) && length(sz_raw) >= 3
                    hx = Float32(sz_raw[1]) / 2.0f0
                    hy = Float32(sz_raw[2]) / 2.0f0
                    hz = Float32(sz_raw[3]) / 2.0f0
                else
                    hx = hy = hz = 0.5f0
                end
            elseif haskey(shape, "side")
                half_side = Float32(shape["side"]) / 2.0f0
                hx = hy = hz = half_side
            else
                hx = hy = hz = 0.5f0
            end
            
            bboxes[i] = (
                xmin = center[1] - hx, xmax = center[1] + hx,
                ymin = center[2] - hy, ymax = center[2] + hy,
                zmin = center[3] - hz, zmax = center[3] + hz
            )
        else
            
            bboxes[i] = (
                xmin = -Inf32, xmax = Inf32,
                ymin = -Inf32, ymax = Inf32,
                zmin = -Inf32, zmax = Inf32
            )
        end
    end
    
    return bboxes
end

"""
    bbox_contains(bbox, pt)

Fast bounding box check.
"""
@inline function bbox_contains(bbox, pt)
    return (pt[1] >= bbox.xmin && pt[1] <= bbox.xmax &&
            pt[2] >= bbox.ymin && pt[2] <= bbox.ymax &&
            pt[3] >= bbox.zmin && pt[3] <= bbox.zmax)
end

"""
    apply_geometric_modifiers!(density, alpha_field, mass_density_field, nodes, elements, shapes, min_density, global_mass_density)

Iterates over elements and modifies the fields based on the shape definitions.
Supports decoupled stiffness, mass, and thermal properties.
"""
function apply_geometric_modifiers!(density::Vector{Float32}, 
                                    alpha_field::Vector{Float32},
                                    mass_density_field::Vector{Float32},
                                    nodes::Matrix{Float32}, 
                                    elements::Matrix{Int}, 
                                    shapes::Vector{Any},
                                    min_density::Float32,
                                    global_mass_density::Float32)
    
    if isempty(shapes)
        return
    end

    nElem = size(elements, 1)
    
    println("Processing geometric density and thermal modifiers...")
    t_start = time()
    
    
    bboxes = precompute_shape_bboxes(shapes)
    
    
    n_shapes = length(shapes)
    shape_types = Vector{String}(undef, n_shapes)
    shape_centers = Vector{Tuple{Float32, Float32, Float32}}(undef, n_shapes)
    shape_params = Vector{Any}(undef, n_shapes)
    
    
    shape_stiffness_ratios = Vector{Float32}(undef, n_shapes)
    shape_specific_masses  = Vector{Float32}(undef, n_shapes)
    shape_alphas           = Vector{Float32}(undef, n_shapes)
    
    for (i, shape) in enumerate(shapes)
        shape_types[i] = lowercase(get(shape, "type", ""))
        
        
        
        stiffness = 1.0f0
        mass = global_mass_density
        alpha = 0.0f0
        
        # 2. Check for legacy 'stiffness_ratio' in root
        if haskey(shape, "stiffness_ratio")
            val = Float32(shape["stiffness_ratio"])
            if val == 0.0f0
                stiffness = 0.0f0
                mass = 0.0f0 
            elseif val > 0.0f0
                stiffness = val
            else 
                stiffness = abs(val)
                alpha = 1.0f0
            end
        end
        
        # 3. Check for new 'properties' dict (Overrides)
        if haskey(shape, "properties")
            props = shape["properties"]
            if haskey(props, "stiffness_ratio")
                stiffness = Float32(props["stiffness_ratio"])
            end
            if haskey(props, "specific_mass")
                mass = Float32(props["specific_mass"])
            end
            if haskey(props, "thermal_expansion")
                alpha = Float32(props["thermal_expansion"])
            end
        end
        
        
        if stiffness == 0.0f0
            mass = 0.0f0
        end
        
        shape_stiffness_ratios[i] = stiffness
        shape_specific_masses[i] = mass
        shape_alphas[i] = alpha
        
        
        if haskey(shape, "center")
            c = shape["center"]
            shape_centers[i] = (Float32(c[1]), Float32(c[2]), Float32(c[3]))
        else
            shape_centers[i] = (0.0f0, 0.0f0, 0.0f0)
        end
        
        
        if shape_types[i] == "sphere"
            shape_params[i] = Float32(shape["diameter"]) / 2.0f0  # radius
        elseif shape_types[i] == "box"
            if haskey(shape, "size")
                sz_raw = shape["size"]
                if isa(sz_raw, AbstractVector) && length(sz_raw) >= 3
                    shape_params[i] = (Float32(sz_raw[1])/2.0f0, Float32(sz_raw[2])/2.0f0, Float32(sz_raw[3])/2.0f0)
                else
                    shape_params[i] = (0.5f0, 0.5f0, 0.5f0)
                end
            elseif haskey(shape, "side")
                half_side = Float32(shape["side"]) / 2.0f0
                shape_params[i] = (half_side, half_side, half_side)
            else
                shape_params[i] = (0.5f0, 0.5f0, 0.5f0)
            end
        else
            shape_params[i] = nothing
        end
    end
    
    
    centroids = Vector{Tuple{Float32, Float32, Float32}}(undef, nElem)
    
    Threads.@threads for e in 1:nElem
        cx = 0.0f0; cy = 0.0f0; cz = 0.0f0
        
        @inbounds for i in 1:8
            node_idx = elements[e, i]
            cx += nodes[node_idx, 1]
            cy += nodes[node_idx, 2]
            cz += nodes[node_idx, 3]
        end
        
        centroids[e] = (cx * 0.125f0, cy * 0.125f0, cz * 0.125f0)
    end
    
    println("  [Optimization] Computed $(nElem) element centroids ($(round(time()-t_start, digits=2))s)")
    
    
    Threads.@threads for e in 1:nElem
        centroid = centroids[e]
        
        
        for i in 1:n_shapes
            
            if !bbox_contains(bboxes[i], centroid)
                continue
            end
            
            
            is_inside = false
            
            if shape_types[i] == "sphere"
                center = shape_centers[i]
                radius = shape_params[i]
                
                dx = centroid[1] - center[1]
                dy = centroid[2] - center[2]
                dz = centroid[3] - center[3]
                dist_sq = dx*dx + dy*dy + dz*dz
                
                is_inside = (dist_sq <= radius*radius)
                
            elseif shape_types[i] == "box"
                center = shape_centers[i]
                half_sizes = shape_params[i]
                
                is_inside = (abs(centroid[1] - center[1]) <= half_sizes[1] &&
                             abs(centroid[2] - center[2]) <= half_sizes[2] &&
                             abs(centroid[3] - center[3]) <= half_sizes[3])
            end
            
            if is_inside
                stiff = shape_stiffness_ratios[i]
                mass  = shape_specific_masses[i]
                alpha = shape_alphas[i]
                
                if stiff == 0.0f0
                    
                    density[e] = min_density
                else
                    
                    density[e] = stiff
                end
                
                
                mass_density_field[e] = mass
                alpha_field[e] = alpha
                
                break
            end
        end
    end
    
    total_time = time() - t_start
    println("  [Optimization] Element density and thermal processing complete ($(round(total_time, digits=2))s)")
    println("                 Processed $(nElem) elements with $(n_shapes) shapes")
    println("                 Throughput: $(round(nElem/total_time/1e6, digits=2))M elements/sec")
end 
 
end
"// # FILE: .\src\Mesh\MeshUtilities.jl";


module MeshUtilities 
 
export inside_sphere, inside_box, element_centroid
 
using LinearAlgebra 
 
""" 
    element_centroid(e, nodes, elements) 
 
Computes the centroid of element `e`.
OPTIMIZED: Uses scalar math to avoid allocating vectors inside threaded loops.
Returns a Tuple (x, y, z).
""" 
function element_centroid(e::Int, nodes::Matrix{Float32}, elements::Matrix{Int}) 
    cx = 0.0f0
    cy = 0.0f0
    cz = 0.0f0

    @inbounds for i in 1:8
        node_idx = elements[e, i]
        cx += nodes[node_idx, 1]
        cy += nodes[node_idx, 2]
        cz += nodes[node_idx, 3]
    end

    inv8 = 0.125f0 
    return (cx * inv8, cy * inv8, cz * inv8)  
end 

""" 
    inside_sphere(pt, center, diam) 
Return true if point `pt` is inside a sphere of diameter `diam` at `center`. 
Accepts pt as Vector or Tuple.
""" 
function inside_sphere(pt, center::Tuple{Float32,Float32,Float32}, diam::Float32) 
    r = diam / 2f0 
     
    dx = pt[1] - center[1]
    dy = pt[2] - center[2]
    dz = pt[3] - center[3]
    return (dx*dx + dy*dy + dz*dz) <= (r*r)
end 

""" 
    inside_box(pt, center, size) 
Return true if point `pt` is inside a box with dimensions `size` (x, y, z) centered at `center`. 
Accepts pt as Vector or Tuple.
""" 
function inside_box(pt, center::Tuple{Float32,Float32,Float32}, box_size::Tuple{Float32,Float32,Float32}) 
    half_x = box_size[1] / 2f0 
    half_y = box_size[2] / 2f0 
    half_z = box_size[3] / 2f0 
     
    return abs(pt[1] - center[1]) <= half_x && 
           abs(pt[2] - center[2]) <= half_y && 
           abs(pt[3] - center[3]) <= half_z 
end 
 
end
"// # FILE: .\src\Optimization\Boundaries.jl";


using Base.Threads
using LinearAlgebra

function create_transition_zone(protected_mask::BitVector, nx::Int, ny::Int, nz::Int, depth::Int=3)
    nElem = length(protected_mask)
    transition_zone = falses(nElem)
    
    for k in 1:nz, j in 1:ny, i in 1:nx
        e = i + (j-1)*nx + (k-1)*nx*ny
        if e < 1 || e > nElem; continue; end
        
        if protected_mask[e]; continue; end
        
        # Check if within 'depth' layers of a protected element
        found_protected = false
        for dk in -depth:depth, dj in -depth:depth, di in -depth:depth
            ni = i + di
            nj = j + dj
            nk = k + dk
            
            if ni >= 1 && ni <= nx && nj >= 1 && nj <= ny && nk >= 1 && nk <= nz
                neighbor_idx = ni + (nj-1)*nx + (nk-1)*nx*ny
                if neighbor_idx >= 1 && neighbor_idx <= nElem && protected_mask[neighbor_idx]
                    found_protected = true
                    break
                end
            end
        end
        
        if found_protected
            transition_zone[e] = true
        end
    end
    
    return transition_zone
end

function blend_transition_zone!(density::Vector{Float32}, 
                                filtered_density::Vector{Float32},
                                protected_mask::BitVector,
                                transition_zone::BitVector,
                                original_density::Vector{Float32},
                                nx::Int, ny::Int, nz::Int,
                                blend_depth::Int=3)
    
    nElem = length(density)
    
    Threads.@threads for k in 1:nz
        for j in 1:ny
            for i in 1:nx
                e = i + (j-1)*nx + (k-1)*nx*ny
                if e < 1 || e > nElem; continue; end
                
                if !transition_zone[e]; continue; end
                
                min_dist = blend_depth + 1.0
                
                for dk in -blend_depth:blend_depth, dj in -blend_depth:blend_depth, di in -blend_depth:blend_depth
                    ni = i + di
                    nj = j + dj
                    nk = k + dk
                    
                    if ni >= 1 && ni <= nx && nj >= 1 && nj <= ny && nk >= 1 && nk <= nz
                        neighbor_idx = ni + (nj-1)*nx + (nk-1)*nx*ny
                        if neighbor_idx >= 1 && neighbor_idx <= nElem && protected_mask[neighbor_idx]
                            dist = sqrt(Float32(di^2 + dj^2 + dk^2))
                            min_dist = min(min_dist, dist)
                        end
                    end
                end
                
                alpha = clamp(min_dist / blend_depth, 0.0f0, 1.0f0)
                smooth_alpha = alpha * alpha * (3.0f0 - 2.0f0 * alpha)
                density[e] = (1.0f0 - smooth_alpha) * original_density[e] + smooth_alpha * filtered_density[e]
            end
        end
    end
end
"// # FILE: .\src\Optimization\DensityUpdate.jl";
// # FILE: .\src\Optimization\DensityUpdate.jl";


module TopologyOptimization 

using LinearAlgebra
using SparseArrays
using Printf  
using Statistics 
using SuiteSparse 
using CUDA
using Base.Threads

using ..Element
using ..Mesh
using ..GPUExplicitFilter
using ..Helpers

export update_density!, reset_filter_cache!

include("Filtering.jl")
include("Boundaries.jl")
include("Verification.jl")

function update_density!(density::Vector{Float32}, 
                         l1_stress_norm_field::Vector{Float32}, 
                         protected_elements_mask::BitVector, 
                         E::Float32, 
                         l1_limit_tension::Float32, 
                         l1_limit_compression::Float32,
                         iter::Int, 
                         number_of_iterations::Int, 
                         original_density::Vector{Float32}, 
                         min_density::Float32,  
                         max_density::Float32, 
                         config::Dict, 
                         elements::Matrix{Int};
                         force_no_cull::Bool=false,
                         cutoff_threshold::Float32=0.05f0,
                         specified_radius::Union{Float32, Nothing}=nothing,
                         max_culling_ratio::Float32=0.05f0,
                         update_damping::Float32=0.5f0)  

    nElem = length(density)
    
    
    
    
    if any(isnan, l1_stress_norm_field)
        println("\n" * "\u001b[31m" * "!!!"^20 * "\u001b[0m")
        println("\u001b[31m" * ">>> [SAFEGUARD] CRITICAL: NaNs detected in stress field (Solver Diverged)." * "\u001b[0m")
        println("\u001b[31m" * ">>> [SAFEGUARD] Skipping topology update to prevent mesh corruption." * "\u001b[0m")
        println("\u001b[31m" * "!!!"^20 * "\n" * "\u001b[0m")
        return 0.0f0, 0.0f0, 0.0f0, 0.0, 0, 0.0
    end

    opt_params = config["optimization_parameters"]
    geom_params = config["geometry"]
    
    nElem_x = Int(geom_params["nElem_x_computed"]) 
    nElem_y = Int(geom_params["nElem_y_computed"])
    nElem_z = Int(geom_params["nElem_z_computed"])
    dx = Float32(geom_params["dx_computed"])
    dy = Float32(geom_params["dy_computed"])
    dz = Float32(geom_params["dz_computed"])
    avg_element_size = (dx + dy + dz) / 3.0f0
    
    proposed_density_field = zeros(Float32, nElem)
    
    
    # 2. Compute "Proposed" Density (Stress-Based Update)
    
    Threads.@threads for e in 1:nElem
        if !protected_elements_mask[e] 
            raw_stress = l1_stress_norm_field[e]
            
            # "Strict" Update Rule:
            limit_e = (raw_stress >= 0) ? l1_limit_tension : l1_limit_compression
            limit_e = max(abs(limit_e), 1.0f-9)
            
            current_l1 = abs(raw_stress)
            target_val = current_l1 / limit_e
            
            # Allow density > 1.0 here so the excess can "diffuse" to neighbors 
            proposed_density_field[e] = max(target_val, min_density)
        else
            
            
            proposed_density_field[e] = original_density[e]
        end
    end

    
    
    
    R_final = 0.0f0
    if specified_radius !== nothing
        R_final = specified_radius
    else
        target_d_phys = Float32(get(opt_params, "minimum_feature_size_physical", 0.0))
        floor_d_elems = Float32(get(opt_params, "minimum_feature_size_elements", 3.0)) 
        
        floor_d_phys = floor_d_elems * avg_element_size
        d_min_phys = 0.0f0
        if target_d_phys > floor_d_phys
            d_min_phys = target_d_phys
        else
            d_min_phys = floor_d_phys
        end
        
        t = Float32(iter) / Float32(number_of_iterations)
        t = clamp(t, 0.0f0, 1.0f0)

        gamma = Float32(get(opt_params, "radius_decay_exponent", 1.8))
        r_max_mult = Float32(get(opt_params, "radius_max_multiplier", 4.0))
        r_min_mult = Float32(get(opt_params, "radius_min_multiplier", 0.5))
        
        decay_factor = 1.0f0 - (t^gamma)
        r_baseline = (r_max_mult * d_min_phys) * decay_factor + (r_min_mult * d_min_phys)
        R_final = r_baseline
    end
    
    filtered_density_field = proposed_density_field
    filter_time = 0.0
    
    
    
    
    if R_final > 1e-4
        t_start = time()
        
        filtered_density_field = GPUExplicitFilter.apply_explicit_filter!(
            proposed_density_field, 
            nElem_x, nElem_y, nElem_z,
            dx, dy, dz, R_final,
            min_density 
        )
        
        filter_time = time() - t_start
        
        if iter % 10 == 1
            verify_boundary_filtering_detailed(proposed_density_field, filtered_density_field, 
                                               nElem_x, nElem_y, nElem_z)
        end
        
        if any(isnan, filtered_density_field) || any(isinf, filtered_density_field)
            println("\u001b[33m" * ">>> [SAFEGUARD] Filter produced NaNs/Infs. Triggering emergency box filter." * "\u001b[0m")
            
            filtered_density_field = apply_emergency_box_filter(
                proposed_density_field, nElem_x, nElem_y, nElem_z
            )
            
            if any(isnan, filtered_density_field)
                println("\u001b[31m" * ">>> [CRITICAL] Emergency filter also failed. Using unfiltered density." * "\u001b[0m")
                filtered_density_field = proposed_density_field
            end
        end
    end
    
    
    filtered_density_field = clamp.(filtered_density_field, min_density, max_density)
    
    
    
    
    
    # This caused "sticking" (halos) around Void regions.
    
    
    
    effective_cutoff = cutoff_threshold
    update_method = get(opt_params, "density_update_method", "hard")
    
    
    
    
    Threads.@threads for e in 1:nElem
        
        if !protected_elements_mask[e]
            
            should_cull = filtered_density_field[e] < effective_cutoff
            
            if should_cull
                density[e] = min_density
            else
                if update_method == "hard"
                    density[e] = 1.0f0
                else
                    density[e] = filtered_density_field[e]
                end
            end
        end
    end
    
    
    
    
    
    Threads.@threads for e in 1:nElem
        if protected_elements_mask[e]
            
            density[e] = original_density[e]
        end
    end
    
    delta_rho = mean(abs.(filtered_density_field .- density))
    
    return delta_rho, R_final, effective_cutoff, filter_time, 0, 0.0
end

end
"// # FILE: .\src\Optimization\Filtering.jl";


using Base.Threads
using SuiteSparse

mutable struct FilterCache
    is_initialized::Bool
    radius::Float32
    K_filter::SuiteSparse.CHOLMOD.Factor{Float64} 
    FilterCache() = new(false, 0.0f0)
end

const GLOBAL_FILTER_CACHE = FilterCache()

function reset_filter_cache!()
    GLOBAL_FILTER_CACHE.is_initialized = false
end

function apply_emergency_box_filter(density::Vector{Float32}, nx::Int, ny::Int, nz::Int)
    println("    [EMERGENCY FILTER] Applying 3x3x3 box filter (CPU)...")
    
    nElem = length(density)
    filtered = copy(density)
    
    Threads.@threads for k in 2:nz-1
        for j in 2:ny-1
            for i in 2:nx-1
                e = i + (j-1)*nx + (k-1)*nx*ny
                
                if e < 1 || e > nElem; continue; end
                
                sum_rho = 0.0f0
                count = 0
                
                for dk in -1:1, dj in -1:1, di in -1:1
                    neighbor_i = i + di
                    neighbor_j = j + dj
                    neighbor_k = k + dk
                    
                    if neighbor_i >= 1 && neighbor_i <= nx &&
                       neighbor_j >= 1 && neighbor_j <= ny &&
                       neighbor_k >= 1 && neighbor_k <= nz
                        
                        neighbor_idx = neighbor_i + (neighbor_j-1)*nx + (neighbor_k-1)*nx*ny
                        
                        if neighbor_idx >= 1 && neighbor_idx <= nElem
                            sum_rho += density[neighbor_idx]
                            count += 1
                        end
                    end
                end
                
                filtered[e] = (count > 0) ? (sum_rho / count) : density[e]
            end
        end
    end
    
    return filtered
end
"// # FILE: .\src\Optimization\GPUExplicitFilter.jl";


module GPUExplicitFilter

using CUDA
using LinearAlgebra
using Printf

export apply_explicit_filter!





"""
    diffusion_kernel_interior!(rho_new, rho_old, dt_over_dx2, nx, ny, nz)
    Standard 7-point Laplacian stencil for interior elements.
    Processes elements that are at least 1 element away from all boundaries.
"""
function diffusion_kernel_interior!(rho_new, rho_old, dt_over_dx2, nx, ny, nz)
    i = (blockIdx().x - 1) * blockDim().x + threadIdx().x
    j = (blockIdx().y - 1) * blockDim().y + threadIdx().y
    k = (blockIdx().z - 1) * blockDim().z + threadIdx().z
    
    
    if i > 1 && i < nx && j > 1 && j < ny && k > 1 && k < nz
        @inbounds begin
            idx = i + (j-1)*nx + (k-1)*nx*ny
            center = rho_old[idx]
            
            
            left   = rho_old[idx - 1]
            right  = rho_old[idx + 1]
            front  = rho_old[idx - nx]
            back   = rho_old[idx + nx]
            bottom = rho_old[idx - nx*ny]
            top    = rho_old[idx + nx*ny]
            
            laplacian = (left + right + front + back + bottom + top - 6.0f0 * center)
            
            
            rho_new[idx] = center + dt_over_dx2 * laplacian
        end
    end
    return nothing
end

"""
    diffusion_kernel_faces!(rho_new, rho_old, dt_over_dx2, nx, ny, nz)
    Neumann BCs (ghost values) for the 6 planar faces.
"""
function diffusion_kernel_faces!(rho_new, rho_old, dt_over_dx2, nx, ny, nz)
    i = (blockIdx().x - 1) * blockDim().x + threadIdx().x
    j = (blockIdx().y - 1) * blockDim().y + threadIdx().y
    k = (blockIdx().z - 1) * blockDim().z + threadIdx().z
    
    if i < 1 || i > nx || j < 1 || j > ny || k < 1 || k > nz; return nothing; end
    
    
    on_x = (i == 1 || i == nx) && (j > 1 && j < ny) && (k > 1 && k < nz)
    on_y = (j == 1 || j == ny) && (i > 1 && i < nx) && (k > 1 && k < nz)
    on_z = (k == 1 || k == nz) && (i > 1 && i < nx) && (j > 1 && j < ny)
    
    if !(on_x || on_y || on_z); return nothing; end
    
    @inbounds begin
        idx = i + (j-1)*nx + (k-1)*nx*ny
        center = rho_old[idx]
        sum_n = 0.0f0
        w_tot = 0.0f0
        
        
        if i > 1
            sum_n += rho_old[idx-1]
            w_tot += 1.0f0
        elseif i == 1
            
            sum_n += (2.0f0*center - rho_old[idx+1])
            w_tot += 1.0f0
        end
        
        if i < nx
            sum_n += rho_old[idx+1]
            w_tot += 1.0f0
        elseif i == nx
            sum_n += (2.0f0*center - rho_old[idx-1])
            w_tot += 1.0f0
        end
        
        
        if j > 1
            sum_n += rho_old[idx-nx]
            w_tot += 1.0f0
        elseif j == 1
            sum_n += (2.0f0*center - rho_old[idx+nx])
            w_tot += 1.0f0
        end
        
        if j < ny
            sum_n += rho_old[idx+nx]
            w_tot += 1.0f0
        elseif j == ny
            sum_n += (2.0f0*center - rho_old[idx-nx])
            w_tot += 1.0f0
        end
        
        
        if k > 1
            sum_n += rho_old[idx-nx*ny]
            w_tot += 1.0f0
        elseif k == 1
            sum_n += (2.0f0*center - rho_old[idx+nx*ny])
            w_tot += 1.0f0
        end
        
        if k < nz
            sum_n += rho_old[idx+nx*ny]
            w_tot += 1.0f0
        elseif k == nz
            sum_n += (2.0f0*center - rho_old[idx-nx*ny])
            w_tot += 1.0f0
        end
        
        rho_new[idx] = center + dt_over_dx2 * (sum_n - w_tot * center)
    end
    return nothing
end

"""
    diffusion_kernel_edges!(rho_new, rho_old, dt_over_dx2, nx, ny, nz)
    Neumann BCs for the 12 edges (lines where 2 faces meet).
"""
function diffusion_kernel_edges!(rho_new, rho_old, dt_over_dx2, nx, ny, nz)
    i = (blockIdx().x - 1) * blockDim().x + threadIdx().x
    j = (blockIdx().y - 1) * blockDim().y + threadIdx().y
    k = (blockIdx().z - 1) * blockDim().z + threadIdx().z
    
    if i < 1 || i > nx || j < 1 || j > ny || k < 1 || k > nz; return nothing; end
    
    
    b_cnt = 0
    if i==1||i==nx; b_cnt+=1; end
    if j==1||j==ny; b_cnt+=1; end
    if k==1||k==nz; b_cnt+=1; end
    
    if b_cnt != 2; return nothing; end
    
    @inbounds begin
        idx = i + (j-1)*nx + (k-1)*nx*ny
        center = rho_old[idx]
        sum_n = 0.0f0
        w_tot = 0.0f0
        
        
        if i > 1
            sum_n += rho_old[idx-1]
            w_tot += 1.0f0
        elseif i == 1 && nx > 1
            sum_n += (2.0f0*center - rho_old[idx+1])
            w_tot += 1.0f0
        end
        
        if i < nx
            sum_n += rho_old[idx+1]
            w_tot += 1.0f0
        elseif i == nx && nx > 1
            sum_n += (2.0f0*center - rho_old[idx-1])
            w_tot += 1.0f0
        end
        
        
        if j > 1
            sum_n += rho_old[idx-nx]
            w_tot += 1.0f0
        elseif j == 1 && ny > 1
            sum_n += (2.0f0*center - rho_old[idx+nx])
            w_tot += 1.0f0
        end
        
        if j < ny
            sum_n += rho_old[idx+nx]
            w_tot += 1.0f0
        elseif j == ny && ny > 1
            sum_n += (2.0f0*center - rho_old[idx-nx])
            w_tot += 1.0f0
        end
        
        
        if k > 1
            sum_n += rho_old[idx-nx*ny]
            w_tot += 1.0f0
        elseif k == 1 && nz > 1
            sum_n += (2.0f0*center - rho_old[idx+nx*ny])
            w_tot += 1.0f0
        end
        
        if k < nz
            sum_n += rho_old[idx+nx*ny]
            w_tot += 1.0f0
        elseif k == nz && nz > 1
            sum_n += (2.0f0*center - rho_old[idx-nx*ny])
            w_tot += 1.0f0
        end
        
        if w_tot > 0.0f0
            rho_new[idx] = center + dt_over_dx2 * (sum_n - w_tot * center)
        else
            rho_new[idx] = center
        end
    end
    return nothing
end

"""
    diffusion_kernel_corners!(rho_new, rho_old, dt_over_dx2, nx, ny, nz)
    Neumann BCs for the 8 corners (points where 3 faces meet).
"""
function diffusion_kernel_corners!(rho_new, rho_old, dt_over_dx2, nx, ny, nz)
    i = (blockIdx().x - 1) * blockDim().x + threadIdx().x
    j = (blockIdx().y - 1) * blockDim().y + threadIdx().y
    k = (blockIdx().z - 1) * blockDim().z + threadIdx().z
    
    if i < 1 || i > nx || j < 1 || j > ny || k < 1 || k > nz; return nothing; end
    
    
    is_corner = (i==1||i==nx) && (j==1||j==ny) && (k==1||k==nz)
    if !is_corner; return nothing; end
    
    @inbounds begin
        idx = i + (j-1)*nx + (k-1)*nx*ny
        center = rho_old[idx]
        sum_n = 0.0f0
        w_tot = 0.0f0
        
        
        if i > 1
            sum_n += rho_old[idx-1]
            w_tot += 1.0f0
        elseif i == 1 && nx > 1
            sum_n += (2.0f0*center - rho_old[idx+1])
            w_tot += 1.0f0
        end
        
        if i < nx
            sum_n += rho_old[idx+1]
            w_tot += 1.0f0
        elseif i == nx && nx > 1
            sum_n += (2.0f0*center - rho_old[idx-1])
            w_tot += 1.0f0
        end
        
        
        if j > 1
            sum_n += rho_old[idx-nx]
            w_tot += 1.0f0
        elseif j == 1 && ny > 1
            sum_n += (2.0f0*center - rho_old[idx+nx])
            w_tot += 1.0f0
        end
        
        if j < ny
            sum_n += rho_old[idx+nx]
            w_tot += 1.0f0
        elseif j == ny && ny > 1
            sum_n += (2.0f0*center - rho_old[idx-nx])
            w_tot += 1.0f0
        end
        
        
        if k > 1
            sum_n += rho_old[idx-nx*ny]
            w_tot += 1.0f0
        elseif k == 1 && nz > 1
            sum_n += (2.0f0*center - rho_old[idx+nx*ny])
            w_tot += 1.0f0
        end
        
        if k < nz
            sum_n += rho_old[idx+nx*ny]
            w_tot += 1.0f0
        elseif k == nz && nz > 1
            sum_n += (2.0f0*center - rho_old[idx-nx*ny])
            w_tot += 1.0f0
        end
        
        if w_tot > 0.0f0
            rho_new[idx] = center + dt_over_dx2 * (sum_n - w_tot * center)
        else
            rho_new[idx] = center
        end
    end
    return nothing
end





"""
    apply_explicit_filter!(density, nx, ny, nz, dx, dy, dz, radius, min_density)

OPTIMIZED VERSION:
1. Dynamic Slab Sizing: Utilizes all available VRAM instead of hardcoded 500MB.
2. Optimized Thread Blocks: (32, 4, 4) for memory coalescing on X-axis.
3. Execution Timer: Logs performance.
4. Sparsity Culling: Skips processing for empty slabs.
"""
function apply_explicit_filter!(density::Vector{Float32}, 
                                nx::Int, ny::Int, nz::Int,
                                dx::Float32, dy::Float32, dz::Float32,
                                radius::Float32,
                                min_density::Float32=0.0001f0) 
    
    if !CUDA.functional(); return density; end
    
    t_start = time()
    
    
    D = (radius^2) / 6.0f0
    avg_dx = (dx + dy + dz) / 3.0f0
    dt_stable = 0.15f0 * (avg_dx^2) / D
    n_steps = max(10, round(Int, radius / avg_dx))
    dt_over_dx2 = dt_stable * D / (avg_dx^2)
    
    halo = 2
    
    
    free_mem = CUDA.available_memory()
    bytes_per_node = 8 
    
    
    usable_mem = max(500 * 1024^2, free_mem - (500 * 1024^2))
    max_nodes = div(usable_mem, bytes_per_node)
    
    slice_size = nx * ny
    max_slab_nz = div(max_nodes, slice_size)
    if max_slab_nz < (halo*2 + 1); max_slab_nz = halo*2 + 1; end 
    
    n_slabs = cld(nz, max_slab_nz - 2*halo)
    
    
    
    threads = (32, 4, 4)
    
    println(@sprintf("    [ExplicitFilter] Radius=%.3f, Steps=%d, dt=%.2e, Slabs=%d (Unclamped Diffusion)", 
                     radius, n_steps, dt_stable, n_slabs))
    
    filtered_density = copy(density)
    
    skipped_slabs = 0
    
    for slab_idx in 1:n_slabs
        z_start = max(1, (slab_idx - 1) * (max_slab_nz - 2*halo) + 1 - halo)
        z_end   = min(nz, z_start + max_slab_nz - 1)
        slab_nz = z_end - z_start + 1
        slab_size = nx * ny * slab_nz
        
        
        slab_data = zeros(Float32, slab_size)
        Threads.@threads for k in 1:slab_nz
            global_k = z_start + k - 1
            start_g = 1 + (global_k - 1) * nx * ny
            end_g   = start_g + nx * ny - 1
            start_l = 1 + (k - 1) * nx * ny
            end_l   = start_l + nx * ny - 1
            slab_data[start_l:end_l] = density[start_g:end_g]
        end
        
        
        # If the max density in this slab (including halos) is "Void",
        
        
        max_val = maximum(slab_data)
        
        
        if max_val <= (min_density * 1.01f0 + 1.0f-5)
            skipped_slabs += 1
            continue
        end
        
        rho_gpu = CuArray(slab_data)
        rho_new_gpu = CUDA.zeros(Float32, slab_size)
        
        blocks = (cld(nx, threads[1]), cld(ny, threads[2]), cld(slab_nz, threads[3]))
        
        for step in 1:n_steps
            @cuda threads=threads blocks=blocks diffusion_kernel_interior!(
                rho_new_gpu, rho_gpu, dt_over_dx2, nx, ny, slab_nz
            )
            @cuda threads=threads blocks=blocks diffusion_kernel_faces!(
                rho_new_gpu, rho_gpu, dt_over_dx2, nx, ny, slab_nz
            )
            @cuda threads=threads blocks=blocks diffusion_kernel_edges!(
                rho_new_gpu, rho_gpu, dt_over_dx2, nx, ny, slab_nz
            )
            @cuda threads=threads blocks=blocks diffusion_kernel_corners!(
                rho_new_gpu, rho_gpu, dt_over_dx2, nx, ny, slab_nz
            )
            rho_gpu, rho_new_gpu = rho_new_gpu, rho_gpu
        end
        
        CUDA.synchronize()
        copyto!(slab_data, rho_gpu)
        
        
        valid_z_start = (slab_idx == 1) ? 1 : halo + 1
        valid_z_end   = (slab_idx == n_slabs) ? slab_nz : slab_nz - halo
        
        Threads.@threads for k in valid_z_start:valid_z_end
            global_k = z_start + k - 1
            start_g = 1 + (global_k - 1) * nx * ny
            end_g   = start_g + nx * ny - 1
            start_l = 1 + (k - 1) * nx * ny
            end_l   = start_l + nx * ny - 1
            filtered_density[start_g:end_g] = slab_data[start_l:end_l]
        end
        
        CUDA.unsafe_free!(rho_gpu); CUDA.unsafe_free!(rho_new_gpu)
    end
    
    GC.gc(); CUDA.reclaim()
    
    elapsed = time() - t_start
    println(@sprintf("    [ExplicitFilter] R=%.3f, Slabs=%d/%d (Skipped %d Empty), Time=%.2fs", 
                     radius, n_slabs - skipped_slabs, n_slabs, skipped_slabs, elapsed))
    
    return filtered_density
end

end
"// # FILE: .\src\Optimization\TopOpt.jl";


module TopologyOptimization 

using LinearAlgebra
using SparseArrays
using Printf  
using Statistics 
using SuiteSparse 
using CUDA
using Base.Threads

using ..Element
using ..Mesh
using ..GPUExplicitFilter
using ..Helpers

export update_density!, reset_filter_cache!


include("Filtering.jl")
include("Boundaries.jl")
include("Verification.jl")
include("DensityUpdate.jl")

end
"// # FILE: .\src\Optimization\Verification.jl";


using Printf

function verify_boundary_filtering_detailed(density::Vector{Float32}, filtered::Vector{Float32}, 
                                            nx::Int, ny::Int, nz::Int)
    
    interior_changed = 0; interior_total = 0
    faces_changed = 0; faces_total = 0
    edges_changed = 0; edges_total = 0
    corners_changed = 0; corners_total = 0
    
    nElem = length(density)

    for k in 1:nz, j in 1:ny, i in 1:nx
        e = i + (j-1)*nx + (k-1)*nx*ny
        
        changed = abs(density[e] - filtered[e]) > 1e-6
        
        on_boundary_count = 0
        if i == 1 || i == nx; on_boundary_count += 1; end
        if j == 1 || j == ny; on_boundary_count += 1; end
        if k == 1 || k == nz; on_boundary_count += 1; end
        
        if on_boundary_count == 0
            interior_total += 1
            if changed; interior_changed += 1; end
        elseif on_boundary_count == 1
            faces_total += 1
            if changed; faces_changed += 1; end
        elseif on_boundary_count == 2
            edges_total += 1
            if changed; edges_changed += 1; end
        else  
            corners_total += 1
            if changed; corners_changed += 1; end
        end
    end
    
    println("    [Filter Check] Detailed Boundary Analysis:")
    
    if interior_total > 0
        pct = 100.0 * interior_changed / interior_total
        status = pct > 90.0 ? "" : ""
        println(@sprintf("      %s Interior:  %6d / %6d (%.1f%%)", 
                         status, interior_changed, interior_total, pct))
    end
    
    if faces_total > 0
        pct = 100.0 * faces_changed / faces_total
        status = pct > 90.0 ? "" : ""
        println(@sprintf("      %s Faces:       %6d / %6d (%.1f%%)", 
                         status, faces_changed, faces_total, pct))
    end
    
    if edges_total > 0
        pct = 100.0 * edges_changed / edges_total
        status = pct > 80.0 ? "" : ""
        println(@sprintf("      %s Edges:       %6d / %6d (%.1f%%)", 
                         status, edges_changed, edges_total, pct))
    end
    
    if corners_total > 0
        pct = 100.0 * corners_changed / corners_total
        status = pct > 70.0 ? "" : ""
        println(@sprintf("      %s Corners:     %6d / %6d (%.1f%%)", 
                         status, corners_changed, corners_total, pct))
    end
    
    total_boundary = faces_total + edges_total + corners_total
    total_boundary_changed = faces_changed + edges_changed + corners_changed
    
    if total_boundary > 0
        overall_pct = 100.0 * total_boundary_changed / total_boundary
        if overall_pct < 80.0
            println("    \u001b[33m[WARNING] <80%% of boundaries filtered properly!\u001b[0m")
        else
            println("    \u001b[32m[SUCCESS] Boundary filtering working correctly.\u001b[0m")
        end
    end
end
"// # FILE: .\src\Utils\Diagnostics.jl";


module Diagnostics

using CUDA
using Printf
using Dates
using JSON

export log_status, check_memory, init_log_file, write_iteration_log, write_crash_log
export print_banner, print_info, print_warn, print_error, print_success, print_substep
export log_memory_snapshot, get_hardware_info, log_full_config, config_to_string

const C_RESET   = "\u001b[0m"
const C_BOLD    = "\u001b[1m"
const C_RED     = "\u001b[31m"
const C_GREEN   = "\u001b[32m"
const C_YELLOW  = "\u001b[33m"
const C_BLUE    = "\u001b[34m"
const C_MAGENTA = "\u001b[35m"
const C_CYAN    = "\u001b[36m"
const C_WHITE   = "\u001b[37m"

# UPDATED HEADER: Added "Weight" column
const LOG_HEADER = """
| Iter |  Mesh Size  |  Total El | Active El |  Radius  |  Cutoff  | Compliance | Avg L1 Stress | Vol % |    Weight    | dRho% | Stab% | Err % | Var % | Strk | Status  | Iter Time | VRAM |"""

function get_timestamp()
    return Dates.format(now(), "HH:MM:SS")
end

function print_banner(title::String; char="=", color=C_CYAN)
    width = 90
    println("\n" * color * char^width * C_RESET)
    println(color * C_BOLD * ">>> " * title * C_RESET)
    println(color * char^width * C_RESET)
    flush(stdout)
end

function print_info(msg::String)
    println(" " * C_CYAN * "[INFO] " * C_RESET * msg)
    flush(stdout)
end

function print_warn(msg::String)
    println(" " * C_YELLOW * C_BOLD * "[WARN] " * C_RESET * C_YELLOW * msg * C_RESET)
    flush(stdout)
end

function print_error(msg::String)
    println(" " * C_RED * C_BOLD * "[ERROR] " * C_RESET * C_RED * msg * C_RESET)
    flush(stdout)
end

function print_success(msg::String)
    println(" " * C_GREEN * C_BOLD * "[DONE] " * C_RESET * msg)
    flush(stdout)
end

function print_substep(msg::String)
    println("    " * C_MAGENTA * "-> " * C_RESET * msg)
    flush(stdout)
end

function log_status(msg::String)
    println(C_BOLD * "[$(get_timestamp())] " * C_RESET * msg)
    flush(stdout) 
end

function check_memory()
    if CUDA.functional()
        free_gpu, total_gpu = CUDA.available_memory(), CUDA.total_memory()
        return free_gpu
    end
    return 0
end

function get_hardware_info()
    cpu_threads = Threads.nthreads()
    sys_mem_free = Sys.free_memory() / 1024^3
    sys_mem_total = Sys.total_memory() / 1024^3
    
    gpu_info = "None"
    if CUDA.functional()
        dev = CUDA.device()
        name = CUDA.name(dev)
        free_gpu, total_gpu = CUDA.available_memory(), CUDA.total_memory()
        gpu_info = "$name | VRAM: $(round(free_gpu/1024^3, digits=2)) GB Free / $(round(total_gpu/1024^3, digits=2)) GB Total"
    end

    return """
    Hardware Profile:
      CPU Threads: $cpu_threads
      System RAM:  $(round(sys_mem_free, digits=2)) GB Free / $(round(sys_mem_total, digits=2)) GB Total
      GPU Device:  $gpu_info
      Julia Ver:   $VERSION
    """
end

function format_memory_str()
    if CUDA.functional()
        free_gpu, total_gpu = CUDA.available_memory(), CUDA.total_memory()
        used_gb = (total_gpu - free_gpu) / 1024^3
        total_gb = total_gpu / 1024^3
        pct = (used_gb / total_gb) * 100
        
        col = C_GREEN
        if pct > 80; col = C_YELLOW; end
        if pct > 95; col = C_RED; end
        
        return "$col" * @sprintf("%4.1fG", used_gb) * C_RESET
    end
    return " CPU"
end

function log_memory_snapshot(label::String)
    if CUDA.functional()
        free, total = CUDA.available_memory(), CUDA.total_memory()
        used = total - free
        return @sprintf("[%s] VRAM: %.2f GB Used / %.2f GB Total (%.1f%%)", 
            label, used/1024^3, total/1024^3, (used/total)*100)
    end
    return "[$label] VRAM: N/A"
end

function format_seconds_to_hms(seconds::Float64)
    total_seconds = round(Int, seconds)
    h = div(total_seconds, 3600)
    m = div(total_seconds % 3600, 60)
    s = total_seconds % 60
    return @sprintf("%02d:%02d:%02d", h, m, s)
end

function log_full_config(io::IO, config::Dict, indent::Int=0)
    prefix = " " ^ indent
    for (k, v) in config
        if isa(v, Dict)
            write(io, "$prefix$k:\n")
            log_full_config(io, v, indent + 2)
        elseif isa(v, Vector)
            write(io, "$prefix$k: [")
            join(io, v, ", ")
            write(io, "]\n")
        else
            write(io, "$prefix$k: $v\n")
        end
    end
end

function config_to_string(config::Dict)
    io = IOBuffer()
    log_full_config(io, config)
    return String(take!(io))
end

function init_log_file(filename::String, config::Dict)
    open(filename, "w") do io
        write(io, "================================================================================\n")
        write(io, "HEXA FEM TOPOLOGY OPTIMIZATION LOG\n")
        write(io, "Start Date: $(now())\n")
        write(io, "================================================================================\n\n")
        
        write(io, "--- HARDWARE INFO ---\n")
        write(io, get_hardware_info())
        write(io, "\n")

        write(io, "--- CONFIGURATION ECHO ---\n")
        log_full_config(io, config)
        write(io, "\n")
        
        write(io, "="^230 * "\n") 
        write(io, LOG_HEADER * "\n")
    end
    print_success("Log file initialized at: $filename")
end

# Helper to format numbers as Millions (e.g., 3400000 -> "3.40M")
function fmt_millions(val::Real)
    return @sprintf("%6.2fM", val / 1.0e6)
end

function write_iteration_log(filename::String, iter, mesh_dims_str, nTotal, nActive, 
                             filter_R, threshold, compliance, strain_energy, avg_l1, 
                             vol_frac, delta_rho, refine_status, time_sec, 
                             lin_residual=0.0, precond_type="-",
                             stability_metric=0.0, stress_metric=0.0, streak=0, variance_metric=0.0,
                             current_weight=0.0)
    
    vram_str_clean = replace(format_memory_str(), r"\u001b\[[0-9;]*m" => "") 
    vram_str_colored = format_memory_str() 
    
    wall_time = Dates.format(now(), "HH:MM:SS")
    time_hms = format_seconds_to_hms(Float64(time_sec))
    
    # Format counts to "M" notation
    str_total  = fmt_millions(nTotal)
    str_active = fmt_millions(nActive)

    f_R = Float64(filter_R)
    f_th = Float64(threshold)
    f_comp = Float64(compliance)
    f_l1 = Float64(avg_l1)
    f_vf = Float64(vol_frac)
    f_dr = Float64(delta_rho)
    
    f_stab = Float64(stability_metric) * 100.0
    f_err = Float64(stress_metric) * 100.0
    f_var = Float64(variance_metric) * 100.0  
    i_streak = Int(streak)
    
    f_weight = Float64(current_weight)

    stat_col = C_RESET
    if refine_status == "Refined"; stat_col = C_CYAN; end
    if occursin("Relaxing", refine_status); stat_col = C_MAGENTA; end
    if refine_status == "Skip"; stat_col = C_YELLOW; end
    if refine_status == "Backtrack"; stat_col = C_RED; end

    
    line_console = @sprintf("| %s%4d%s | %11s | %9s | %9s | %8.4f | %8.3f | %10.2e | %13.2e | %5.1f%% | %10.2e | %5.1f%% | %5.1f%% | %5.1f%% | %5.1f%% | %4d | %s%9s%s | %9s | %s |",
                        C_BOLD, iter, C_RESET, mesh_dims_str, 
                        str_total, str_active, 
                        f_R, f_th,
                        f_comp, f_l1, f_vf*100, f_weight, f_dr*100, 
                        f_stab, f_err, f_var, i_streak,
                        stat_col, refine_status, C_RESET, time_hms, vram_str_colored)

    
    line_file = @sprintf("| %4d | %11s | %9s | %9s | %8.4f | %8.3f | %10.2e | %13.2e | %5.1f%% | %10.2e | %5.1f%% | %5.1f%% | %5.1f%% | %5.1f%% | %4d | %9s | %9s | %4s |",
                        iter, mesh_dims_str, 
                        str_total, str_active,
                        f_R, f_th,
                        f_comp, f_l1, f_vf*100, f_weight, f_dr*100, 
                        f_stab, f_err, f_var, i_streak,
                        refine_status, time_hms, vram_str_clean)
    
    try
        open(filename, "a") do io
            println(io, line_file)
        end
    catch e
        println(C_RED * "[LOG ERROR] Could not write to log file." * C_RESET)
    end
    
    if iter == 1 || iter % 10 == 0 || refine_status != "Nominal"
        println("\n" * C_BOLD * LOG_HEADER * C_RESET)
    end
    println(line_console)
    flush(stdout)
end

function write_crash_log(filename, stage, err, stack, iter, config, density_sample)
    try
        open(filename, "a") do io
            write(io, "\n" * "="^80 * "\n")
            write(io, "CRASH REPORT [$(Dates.now())]\n")
            write(io, "="^80 * "\n")
            write(io, "Stage: $stage\n")
            write(io, "Iteration: $iter\n")
            write(io, "Error: $err\n")
            write(io, "\nStacktrace:\n")
            showerror(io, err, stack)
            write(io, "\n\nSystem State:\n")
            write(io, get_hardware_info())
            write(io, "="^80 * "\n")
        end
        print_warn("Detailed crash log written to: $filename")
    catch e
        print_error("Could not write crash log: $e")
    end
end

end
"// # FILE: .\src\Utils\Helpers.jl";
// 
module Helpers 

using CUDA 
using Printf

export expand_element_indices, nodes_from_location, parse_location_component 
export calculate_element_distribution, has_enough_gpu_memory, clear_gpu_memory, get_max_feasible_elements
export enforce_gpu_memory_safety, log_gpu_state, is_gmg_feasible_on_gpu, cleanup_memory
export estimate_required_iterations

function cleanup_memory()
    GC.gc()
    if CUDA.functional()
        CUDA.reclaim()
    end
end

function expand_element_indices(elem_inds, dims) 
    nElem_x = dims[1] - 1 
    nElem_y = dims[2] - 1 
    nElem_z = dims[3] - 1 
    inds = Vector{Vector{Int}}() 
    for d in 1:3 
        if (typeof(elem_inds[d]) == String && elem_inds[d] == ":") 
            if d == 1 
                push!(inds, collect(1:nElem_x)) 
            elseif d == 2 
                push!(inds, collect(1:nElem_y)) 
            elseif d == 3 
                push!(inds, collect(1:nElem_z)) 
            end 
        else 
            push!(inds, [Int(elem_inds[d])]) 
        end 
    end 
    result = Int[] 
    for i in inds[1], j in inds[2], k in inds[3] 
        eidx = i + (j-1)*nElem_x + (k-1)*nElem_x*nElem_y 
        push!(result, eidx) 
    end 
    return result 
end 

function nodes_from_location(loc::Vector, dims) 
    nNodes_x, nNodes_y, nNodes_z = dims 
    ix = parse_location_component(loc[1], nNodes_x) 
    iy = parse_location_component(loc[2], nNodes_y) 
    iz = parse_location_component(loc[3], nNodes_z) 
    nodes = Int[] 
    for k in iz, j in iy, i in ix 
        node = i + (j-1)*nNodes_x + (k-1)*nNodes_x*nNodes_y 
        push!(nodes, node) 
    end 
    return nodes 
end 

function parse_location_component(val, nNodes::Int) 
    if val == ":" 
        return collect(1:nNodes) 
    elseif isa(val, String) && endswith(val, "%") 
        perc = parse(Float64, replace(val, "%"=>"")) / 100.0 
        idx = round(Int, 1 + perc*(nNodes-1)) 
        return [idx] 
    elseif isa(val, Number) 
        if 0.0 <= val <= 1.0 
            idx = round(Int, 1 + val*(nNodes-1)) 
            return [idx] 
        else 
            idx = clamp(round(Int, val), 1, nNodes) 
            return [idx] 
        end 
    else 
        error("Invalid location component: $val") 
    end 
end 

function clear_gpu_memory() 
    if !CUDA.functional() 
        return (0, 0) 
    end 
    GC.gc() 
    CUDA.reclaim() 

    final_free, total = CUDA.available_memory(), CUDA.total_memory() 
    return (final_free, total) 
end 

function log_gpu_state(label::String)
    if CUDA.functional()
        free_mem, total_mem = CUDA.available_memory(), CUDA.total_memory()
        used_mem = total_mem - free_mem
        @printf("    [GPU STATE] %-25s | Used: %6.2f GB | Free: %6.2f GB\n", 
                label, used_mem/1024^3, free_mem/1024^3)
        flush(stdout)
    end
end

function estimate_bytes_per_element(matrix_free::Bool=true, use_double::Bool=false)
    prec_mult = use_double ? 2.0 : 1.0

    if matrix_free
        return 80.0 * prec_mult 
    else
        return 12000.0
    end
end

function is_gmg_feasible_on_gpu(nElem::Int, use_double::Bool; config::Dict=Dict())
    if !CUDA.functional()
        return (false, 0.0, 0.0)
    end
    
    if haskey(config, "machine_limits")
        limits = config["machine_limits"]
        max_safe = get(limits, "MAX_GMG_ELEMENTS", 5_000_000)
        
        if use_double
            max_safe = div(max_safe, 2)
        end
        
        if nElem <= max_safe
             return (true, 0.0, 0.0) 
        else
             return (false, Float64(nElem), Float64(max_safe))
        end
    end

    cleanup_memory()
    free_mem = Float64(CUDA.available_memory())
    
    prec_mult = use_double ? 2.0 : 1.0
    bytes_per_elem_total = 80.0 * prec_mult * 1.15
    required_mem = nElem * bytes_per_elem_total
    safety_buffer = 400 * 1024^2
    available_for_job = free_mem - safety_buffer
    
    required_gb = required_mem / 1024^3
    free_gb = free_mem / 1024^3
    
    return (required_mem < available_for_job, required_gb, free_gb)
end

function get_max_feasible_elements(matrix_free::Bool=true; safety_factor::Float64=0.95, bytes_per_elem::Int=0)
    if !CUDA.functional() 
        return 5_000_000 
    end 
      
    free_mem, total_mem = CUDA.available_memory(), CUDA.total_memory() 
    if safety_factor == 0.95; safety_factor = 0.99; end 
    usable_mem = free_mem * safety_factor 
    bpe = (bytes_per_elem > 0) ? bytes_per_elem : estimate_bytes_per_element(matrix_free) 
    max_elems = floor(Int, usable_mem / bpe) 
    return max_elems
end
 
function estimate_gpu_memory_required(nNodes, nElem, matrix_free::Bool=true) 
    return nElem * estimate_bytes_per_element(matrix_free)
end
 
function has_enough_gpu_memory(nNodes, nElem, matrix_free::Bool=true) 
    if !CUDA.functional(); return false; end 
    try 
        free_mem, total_mem = CUDA.available_memory(), CUDA.total_memory() 
        required_mem = estimate_gpu_memory_required(nNodes, nElem, matrix_free) 
        utilization_limit = 0.99 
        usable_mem = free_mem * utilization_limit 
        req_gb = required_mem / 1024^3 
        avail_gb = usable_mem / 1024^3

        if required_mem > usable_mem 
            @warn "GPU Memory Estimate:" 
            @printf("    Required:  %.2f GB\n", req_gb) 
            @printf("    Available: %.2f GB\n", avail_gb) 
            return true 
        end 
        return true 
    catch e 
        println("Error checking GPU memory: $e") 
        return true 
    end 
end 

function calculate_element_distribution(length_x, length_y, length_z, target_elem_count) 
    total_volume = length_x * length_y * length_z 
    k = cbrt(target_elem_count / total_volume) 
    nElem_x = max(1, round(Int, k * length_x)) 
    nElem_y = max(1, round(Int, k * length_y)) 
    nElem_z = max(1, round(Int, k * length_z)) 
    dx = length_x / nElem_x 
    dy = length_y / nElem_y 
    dz = length_z / nElem_z 
    actual_elem_count = nElem_x * nElem_y * nElem_z 
    return nElem_x, nElem_y, nElem_z, Float32(dx), Float32(dy), Float32(dz), actual_elem_count
end

function enforce_gpu_memory_safety(n_active_elem::Int, n_nodes::Int, use_double_precision::Bool, use_multigrid::Bool)
    if !CUDA.functional(); return; end
    cleanup_memory()
    free_mem = CUDA.available_memory()
    
    bytes_per = estimate_bytes_per_element(true, use_double_precision)
    
    if use_multigrid
        bytes_per *= 1.2
    end

    mem_est = n_active_elem * bytes_per
    
    req_gb = mem_est / 1024^3
    avail_gb = free_mem / 1024^3
    
    if mem_est > free_mem
        println("\n\u001b[31m>>> [MEMORY GUARD] VRAM DEFICIT DETECTED (Active: $(Base.format_bytes(n_active_elem)))")
        @printf("    Req: %.2f GB | Free: %.2f GB\n", req_gb, avail_gb)
        println("    [WARNING] Expect SEVERE slowdowns (PCIe swapping) or Crash.")
        flush(stdout)
    else
        @printf("    [Memory Guard] %.2f GB est / %.2f GB free. Safe.\n", req_gb, avail_gb)
    end
end

"""
    estimate_required_iterations(config, current_elems)

Estimates the required number of iterations based on:
1. Controller settling time (base load)
2. Mesh Refinement magnitude (target / start ratio)
3. Annealing load (radius max / radius min)
4. Domain scale (larger domains propagate information slower)
"""
function estimate_required_iterations(config::Dict, current_elems::Int)
    opt = get(config, "optimization_parameters", Dict())
    mesh_conf = get(config, "mesh_settings", Dict())
    
    
    
    target_raw = get(mesh_conf, "final_target_of_active_elements", current_elems)
    target_elems = isa(target_raw, String) ? parse(Int, replace(target_raw, "_"=>"")) : Int(target_raw)
    
    growth_ratio = max(1.0, target_elems / current_elems)
    
    iter_refine = 30.0 * log2(growth_ratio) 

    
    r_max = Float32(get(opt, "radius_max_multiplier", 1.0))
    r_min = Float32(get(opt, "radius_min_multiplier", 1.0))
    
    anneal_ratio = max(1.0, r_max / max(0.1, r_min))
    
    
    iter_anneal = 40.0 * (anneal_ratio - 1.0) 

    
    
    iter_base = 50.0

    
    
    scale_factor = 1.0 + 0.2 * log10(max(1, target_elems) / 1_000_000)

    
    estimated = (iter_base + iter_refine + iter_anneal) * scale_factor
    
    
    return clamp(round(Int, estimated), 50, 1000)
end
 
end
"// # FILE: .\src\Utils\get_package_versions.jl";

import Pkg

const TARGET_FILE = joinpath(@__DIR__, "..", "..", "Project.toml") # Adjusted path to root

println(">>> Generating Project.toml from current environment...")

deps = Pkg.dependencies()
sorted_deps = sort(collect(deps), by=x->x[2].name)

buffer = IOBuffer()

println(buffer, "name = \"HEXA_TopOpt\"")
println(buffer, "uuid = \"a1b2c3d4-e5f6-4a5b-9c8d-7e6f5g4h3i2j\"")
println(buffer, "authors = [\"User\"]")
println(buffer, "version = \"1.0.0\"")
println(buffer, "")

println(buffer, "[deps]")
for (uuid, pkg) in sorted_deps
    if pkg.is_direct_dep
        println(buffer, "$(pkg.name) = \"$uuid\"")
    end
end
println(buffer, "")

println(buffer, "[compat]")

println(buffer, "julia = \"1.6\"") 

for (uuid, pkg) in sorted_deps
    if pkg.is_direct_dep
        if pkg.version !== nothing
            # FIX: Removed the "=" sign. 
            # "$(pkg.version)" implies semver compatibility (e.g., "1.2.3" allows "1.2.4" and "1.9.0")
            println(buffer, "$(pkg.name) = \"$(pkg.version)\"")
        else
            println(buffer, "# Warning: Could not detect version for $(pkg.name)")
        end
    end
end

new_content = String(take!(buffer))

if isfile(TARGET_FILE)
    mv(TARGET_FILE, TARGET_FILE * ".bak", force=true)
    println(">>> Existing Project.toml backed up to Project.toml.bak")
end

open(TARGET_FILE, "w") do io
    write(io, new_content)
end

println("-"^60)
println(">>> SUCCESS: Project.toml has been written successfully.")
println(">>> Location: $TARGET_FILE")
println("-"^60)
